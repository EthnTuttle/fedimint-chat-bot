logo [../../../static.files/rust-logo-151179464ae7ed46.svg]../../../fedimint_core/index.html
? [../../../help.html]
Change settings [../../../static.files/wheel-5ec35bf9ca753509.svg]../../../settings.html

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213


/// Copied from `tokio_stream` 0.1.12 to use our optional Send bounds
pub mod broadcaststream;

use std::borrow::Cow;
use std::fmt::{Debug, Display, Formatter};
use std::future::Future;
use std::io::Write;
use std::path::Path;
use std::pin::Pin;
use std::{fs, io};

use anyhow::format_err;
use futures::StreamExt;
use tokio::io::AsyncWriteExt;
use tracing::debug;
use url::Url;

use crate::task::MaybeSend;
use crate::{apply, async_trait_maybe_send, maybe_add_send};

/// Future that is `Send` unless targeting WASM
pub type BoxFuture<'a, T> = Pin<Box<maybe_add_send!(dyn Future<Output = T> + 'a)>>;

/// Stream that is `Send` unless targeting WASM
pub type BoxStream<'a, T> = Pin<Box<maybe_add_send!(dyn futures::Stream<Item = T> + 'a)>>;

#[apply(async_trait_maybe_send!)]
pub trait NextOrPending {
    type Output;

    async fn next_or_pending(&mut self) -> Self::Output;

    async fn ok(&mut self) -> anyhow::Result<Self::Output>;
}

#[apply(async_trait_maybe_send!)]
impl<S> NextOrPending for S
where
    S: futures::Stream + Unpin + MaybeSend,
    S::Item: MaybeSend,
{
    type Output = S::Item;

    /// Waits for the next item in a stream. If the stream is closed while
    /// waiting, returns an error.  Useful when expecting a stream to progress.
    async fn ok(&mut self) -> anyhow::Result<Self::Output> {
        match self.next().await {
            Some(item) => Ok(item),
            None => Err(format_err!("Stream was unexpectedly closed")),
        }
    }

    /// Waits for the next item in a stream. If the stream is closed while
    /// waiting the future will be pending forever. This is useful in cases
    /// where the future will be cancelled by shutdown logic anyway and handling
    /// each place where a stream may terminate would be too much trouble.
    async fn next_or_pending(&mut self) -> Self::Output {
        match self.next().await {
            Some(item) => item,
            None => {
                debug!("Stream ended in next_or_pending, pending forever to avoid throwing an error on shutdown");
                std::future::pending().await
            }
        }
    }
}

// TODO: make fully RFC1738 conformant
/// Wrapper for `Url` that only prints the scheme, domain, port and path portion
/// of a `Url` in its `Display` implementation. This is useful to hide private
/// information like user names and passwords in logs or UIs.
///
/// The output is not fully RFC1738 conformant but good enough for our current
/// purposes.
pub struct SanitizedUrl<'a>(Cow<'a, Url>);

impl<'a> SanitizedUrl<'a> {
    pub fn new_owned(url: Url) -> SanitizedUrl<'static> {
        SanitizedUrl(Cow::Owned(url))
    }

    pub fn new_borrowed(url: &'a Url) -> SanitizedUrl<'a> {
        SanitizedUrl(Cow::Borrowed(url))
    }
}

impl<'a> Display for SanitizedUrl<'a> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}://", self.0.scheme())?;

        if let Some(host) = self.0.host_str() {
            write!(f, "{host}")?;
        }

        if let Some(port) = self.0.port() {
            write!(f, ":{port}")?;
        }

        write!(f, "{}", self.0.path())?;

        Ok(())
    }
}

impl<'a> Debug for SanitizedUrl<'a> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "SanitizedUrl(")?;
        Display::fmt(self, f)?;
        write!(f, ", has_password={}", self.0.password().is_some())?;
        write!(f, ", has_username={}", !self.0.username().is_empty())?;
        write!(f, ")")?;
        Ok(())
    }
}

/// Write out a new file (like [`std::fs::write`] but fails if file already
/// exists)
#[cfg(not(target_family = "wasm"))]
pub fn write_new<P: AsRef<Path>, C: AsRef<[u8]>>(path: P, contents: C) -> io::Result<()> {
    fs::File::options()
        .write(true)
        .create_new(true)
        .open(path)?
        .write_all(contents.as_ref())
}

#[cfg(not(target_family = "wasm"))]
pub fn write_overwrite<P: AsRef<Path>, C: AsRef<[u8]>>(path: P, contents: C) -> io::Result<()> {
    fs::File::options()
        .write(true)
        .create(true)
        .open(path)?
        .write_all(contents.as_ref())
}

#[cfg(not(target_family = "wasm"))]
pub async fn write_overwrite_async<P: AsRef<Path>, C: AsRef<[u8]>>(
    path: P,
    contents: C,
) -> io::Result<()> {
    tokio::fs::OpenOptions::new()
        .write(true)
        .create(true)
        .open(path)
        .await?
        .write_all(contents.as_ref())
        .await
}

#[cfg(not(target_family = "wasm"))]
pub async fn write_new_async<P: AsRef<Path>, C: AsRef<[u8]>>(
    path: P,
    contents: C,
) -> io::Result<()> {
    tokio::fs::OpenOptions::new()
        .write(true)
        .create_new(true)
        .open(path)
        .await?
        .write_all(contents.as_ref())
        .await
}

#[cfg(test)]
mod tests {
    use std::time::Duration;

    use fedimint_core::task::Elapsed;
    use futures::FutureExt;
    use url::Url;

    use crate::task::timeout;
    use crate::util::{NextOrPending, SanitizedUrl};

    #[test]
    fn test_sanitized_url() {
        let test_cases = vec![
            ("http://1.2.3.4:80/foo", "http://1.2.3.4/foo", "SanitizedUrl(http://1.2.3.4/foo, has_password=false, has_username=false)"),
            ("http://1.2.3.4:81/foo", "http://1.2.3.4:81/foo", "SanitizedUrl(http://1.2.3.4:81/foo, has_password=false, has_username=false)"),
            ("fedimint://1.2.3.4:1000/foo", "fedimint://1.2.3.4:1000/foo", "SanitizedUrl(fedimint://1.2.3.4:1000/foo, has_password=false, has_username=false)"),
            ("fedimint://foo:bar@domain.com:1000/foo", "fedimint://domain.com:1000/foo", "SanitizedUrl(fedimint://domain.com:1000/foo, has_password=true, has_username=true)"),
            ("fedimint://foo@1.2.3.4:1000/foo", "fedimint://1.2.3.4:1000/foo", "SanitizedUrl(fedimint://1.2.3.4:1000/foo, has_password=false, has_username=true)"),
        ];

        for (url_str, sanitized_display_expected, sanitized_debug_expected) in test_cases {
            let url = Url::parse(url_str).unwrap();
            let sanitized_url = SanitizedUrl::new_borrowed(&url);

            let sanitized_display = format!("{sanitized_url}");
            assert_eq!(
                sanitized_display, sanitized_display_expected,
                "Display implementation out of spec"
            );

            let sanitized_debug = format!("{sanitized_url:?}");
            assert_eq!(
                sanitized_debug, sanitized_debug_expected,
                "Debug implementation out of spec"
            );
        }
    }

    #[tokio::test]
    async fn test_next_or_pending() {
        let mut stream = futures::stream::iter(vec![1, 2]);
        assert_eq!(stream.next_or_pending().now_or_never(), Some(1));
        assert_eq!(stream.next_or_pending().now_or_never(), Some(2));
        assert!(matches!(
            timeout(Duration::from_millis(100), stream.next_or_pending()).await,
            Err(Elapsed)
        ));
    }
}


