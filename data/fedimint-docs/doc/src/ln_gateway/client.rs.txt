logo [../../static.files/rust-logo-151179464ae7ed46.svg]../../ln_gateway/index.html
? [../../help.html]
Change settings [../../static.files/wheel-5ec35bf9ca753509.svg]../../settings.html

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128


use std::collections::BTreeMap;
use std::fmt::Debug;
use std::path::PathBuf;
use std::sync::Arc;

use fedimint_client::module::gen::ClientModuleGenRegistry;
use fedimint_client::secret::PlainRootSecretStrategy;
use fedimint_client::ClientBuilder;
use fedimint_core::api::{DynGlobalApi, GlobalFederationApi, WsClientConnectInfo, WsFederationApi};
use fedimint_core::core::ModuleInstanceId;
use fedimint_core::db::DatabaseTransaction;
use fedimint_core::task::TaskGroup;
use futures::StreamExt;
use lightning::routing::gossip::RoutingFees;

use crate::db::{FederationConfig, FederationIdKey, FederationIdKeyPrefix};
use crate::lnrpc_client::ILnRpcClient;
use crate::ng::GatewayClientGen;
use crate::{GatewayError, Result};

#[derive(Debug, Clone)]
pub struct StandardGatewayClientBuilder {
    work_dir: PathBuf,
    registry: ClientModuleGenRegistry,
    primary_module: ModuleInstanceId,
}

impl StandardGatewayClientBuilder {
    pub fn new(
        work_dir: PathBuf,
        registry: ClientModuleGenRegistry,
        primary_module: ModuleInstanceId,
    ) -> Self {
        Self {
            work_dir,
            registry,
            primary_module,
        }
    }
}

impl StandardGatewayClientBuilder {
    pub async fn build(
        &self,
        config: FederationConfig,
        node_pub_key: secp256k1::PublicKey,
        lnrpc: Arc<dyn ILnRpcClient>,
        tg: &mut TaskGroup,
        old_client: Option<fedimint_client::Client>,
    ) -> Result<fedimint_client::Client> {
        let federation_id = config.config.federation_id;

        let mut registry = self.registry.clone();
        registry.attach(GatewayClientGen {
            lnrpc,
            node_pub_key,
            fees: config.fees,
            timelock_delta: config.timelock_delta,
            mint_channel_id: config.mint_channel_id,
        });

        let mut client_builder = ClientBuilder::default();
        client_builder.with_module_gens(registry);
        client_builder.with_primary_module(self.primary_module);
        client_builder.with_config(config.config);
        if let Some(old_client) = old_client {
            client_builder.with_old_client_database(old_client);
        } else {
            let db_path = self.work_dir.join(format!("{federation_id}.db"));
            let db = fedimint_rocksdb::RocksDb::open(db_path).map_err(|e| {
                GatewayError::DatabaseError(anyhow::anyhow!("Error opening rocksdb: {e:?}"))
            })?;
            client_builder.with_database(db);
        }

        client_builder
            // TODO: make this configurable?
            .build::<PlainRootSecretStrategy>(tg)
            .await
            .map_err(|error| {
                tracing::warn!("Error building client: {:?}", error);
                GatewayError::ClientNgError
            })
    }

    pub async fn create_config(
        &self,
        connect: WsClientConnectInfo,
        mint_channel_id: u64,
        fees: RoutingFees,
    ) -> Result<FederationConfig> {
        let api: DynGlobalApi = WsFederationApi::from_connect_info(&[connect.clone()]).into();
        let client_config = api.download_client_config(&connect).await?;
        Ok(FederationConfig {
            mint_channel_id,
            timelock_delta: 10,
            fees,
            config: client_config,
        })
    }

    pub async fn save_config(
        &self,
        config: FederationConfig,
        mut dbtx: DatabaseTransaction<'_>,
    ) -> Result<()> {
        let id = config.config.federation_id;
        dbtx.insert_new_entry(&FederationIdKey { id }, &config)
            .await;
        dbtx.commit_tx_result()
            .await
            .map_err(GatewayError::DatabaseError)
    }

    pub async fn load_configs(
        &self,
        mut dbtx: DatabaseTransaction<'_>,
    ) -> Result<Vec<FederationConfig>> {
        Ok(dbtx
            .find_by_prefix(&FederationIdKeyPrefix)
            .await
            .collect::<BTreeMap<FederationIdKey, FederationConfig>>()
            .await
            .values()
            .cloned()
            .collect::<Vec<_>>())
    }
}


