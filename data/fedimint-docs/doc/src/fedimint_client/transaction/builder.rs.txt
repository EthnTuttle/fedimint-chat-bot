logo [../../../static.files/rust-logo-151179464ae7ed46.svg]../../../fedimint_client/index.html
? [../../../help.html]
Change settings [../../../static.files/wheel-5ec35bf9ca753509.svg]../../../settings.html

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148


use std::sync::Arc;

use fedimint_core::core::{DynInput, DynOutput, IntoDynInstance, KeyPair, ModuleInstanceId};
use fedimint_core::transaction::Transaction;
use fedimint_core::Amount;
use itertools::multiunzip;
use rand::{CryptoRng, RngCore};
use secp256k1_zkp::Secp256k1;

use crate::module::StateGenerator;
use crate::sm::DynState;
use crate::DynGlobalClientContext;

#[derive(Clone)]
pub struct ClientInput<I = DynInput, S = DynState<DynGlobalClientContext>> {
    pub input: I,
    pub keys: Vec<KeyPair>,
    pub state_machines: StateGenerator<S>,
}

impl<I, S> IntoDynInstance for ClientInput<I, S>
where
    I: IntoDynInstance<DynType = DynInput> + 'static,
    S: IntoDynInstance<DynType = DynState<DynGlobalClientContext>> + 'static,
{
    type DynType = ClientInput;

    fn into_dyn(self, module_instance_id: ModuleInstanceId) -> ClientInput {
        ClientInput {
            input: self.input.into_dyn(module_instance_id),
            keys: self.keys,
            state_machines: state_gen_to_dyn(self.state_machines, module_instance_id),
        }
    }
}

#[derive(Clone)]
pub struct ClientOutput<O = DynOutput, S = DynState<DynGlobalClientContext>> {
    pub output: O,
    pub state_machines: StateGenerator<S>,
}

impl<O, S> IntoDynInstance for ClientOutput<O, S>
where
    O: IntoDynInstance<DynType = DynOutput> + 'static,
    S: IntoDynInstance<DynType = DynState<DynGlobalClientContext>> + 'static,
{
    type DynType = ClientOutput;

    fn into_dyn(self, module_instance_id: ModuleInstanceId) -> ClientOutput {
        ClientOutput {
            output: self.output.into_dyn(module_instance_id),
            state_machines: state_gen_to_dyn(self.state_machines, module_instance_id),
        }
    }
}

#[derive(Default, Clone)]
pub struct TransactionBuilder {
    pub(crate) inputs: Vec<ClientInput>,
    pub(crate) outputs: Vec<ClientOutput>,
}

impl TransactionBuilder {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn with_input(mut self, input: ClientInput) -> Self {
        self.inputs.push(input);
        self
    }

    pub fn with_output(mut self, output: ClientOutput) -> Self {
        self.outputs.push(output);
        self
    }

    pub fn build<C, R: RngCore + CryptoRng>(
        self,
        secp_ctx: &Secp256k1<C>,
        mut rng: R,
    ) -> (Transaction, Vec<DynState<DynGlobalClientContext>>)
    where
        C: secp256k1_zkp::Signing + secp256k1_zkp::Verification,
    {
        let (inputs, input_keys, input_states): (Vec<_>, Vec<_>, Vec<_>) = multiunzip(
            self.inputs
                .into_iter()
                .map(|input| (input.input, input.keys, input.state_machines)),
        );
        let (outputs, output_states): (Vec<_>, Vec<_>) = self
            .outputs
            .into_iter()
            .map(|output| (output.output, output.state_machines))
            .unzip();

        let txid = Transaction::tx_hash_from_parts(&inputs, &outputs);

        let signature = if !input_keys.is_empty() {
            let keys = input_keys.into_iter().flatten().collect::<Vec<_>>();

            let signature =
                fedimint_core::transaction::agg_sign(&keys, txid.as_hash(), secp_ctx, &mut rng);
            Some(signature)
        } else {
            None
        };

        let transaction = Transaction {
            inputs,
            outputs,
            signature,
        };

        let states = input_states
            .into_iter()
            .enumerate()
            .chain(output_states.into_iter().enumerate())
            .flat_map(|(idx, state_gen)| state_gen(txid, idx as u64))
            .collect::<Vec<_>>();

        (transaction, states)
    }
}

#[derive(Debug, Eq, PartialEq)]
pub(crate) enum TransactionBuilderBalance {
    Underfunded(Amount),
    Balanced,
    Overfunded(Amount),
}

fn state_gen_to_dyn<S>(
    state_gen: StateGenerator<S>,
    module_instance: ModuleInstanceId,
) -> StateGenerator<DynState<DynGlobalClientContext>>
where
    S: IntoDynInstance<DynType = DynState<DynGlobalClientContext>> + 'static,
{
    Arc::new(move |txid, index| {
        let states = state_gen(txid, index);
        states
            .into_iter()
            .map(|state| state.into_dyn(module_instance))
            .collect()
    })
}


