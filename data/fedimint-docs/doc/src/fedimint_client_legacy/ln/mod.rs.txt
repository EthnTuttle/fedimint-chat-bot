logo [../../../static.files/rust-logo-151179464ae7ed46.svg]../../../fedimint_client_legacy/index.html
? [../../../help.html]
Change settings [../../../static.files/wheel-5ec35bf9ca753509.svg]../../../settings.html

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342


// TODO: once user and mint client are merged, make this private again
pub mod db;
pub mod incoming;
pub mod outgoing;

use std::sync::Arc;
use std::time::Duration;

use bitcoin_hashes::sha256::Hash as Sha256Hash;
use fedimint_core::api::FederationError;
use fedimint_core::config::FederationId;
use fedimint_core::core::client::ClientModule;
use fedimint_core::core::Decoder;
use fedimint_core::db::DatabaseTransaction;
use fedimint_core::module::{ModuleCommon, TransactionItemAmount};
use fedimint_core::task::timeout;
use fedimint_core::Amount;
use futures::StreamExt;
use lightning::routing::gossip::RoutingFees;
use lightning_invoice::Invoice;
use rand::{CryptoRng, RngCore};
use serde::{Deserialize, Serialize};
use thiserror::Error;

use self::db::ConfirmedInvoiceKey;
use self::incoming::ConfirmedInvoice;
use crate::api::{LnFederationApi, WalletFederationApi};
use crate::ln::db::{OutgoingPaymentKey, OutgoingPaymentKeyPrefix};
use crate::ln::incoming::IncomingContractAccount;
use crate::ln::outgoing::{OutgoingContractAccount, OutgoingContractData};
use crate::modules::ln::config::LightningClientConfig;
use crate::modules::ln::contracts::incoming::IncomingContractOffer;
use crate::modules::ln::contracts::outgoing::OutgoingContract;
use crate::modules::ln::contracts::{
    Contract, ContractId, EncryptedPreimage, FundedContract, IdentifiableContract, Preimage,
};
use crate::modules::ln::{
    ContractAccount, ContractOutput, LightningGateway, LightningInput, LightningModuleTypes,
    LightningOutput,
};
use crate::utils::ClientContext;

#[derive(Debug)]
pub struct LnClient {
    pub config: LightningClientConfig,
    pub context: Arc<ClientContext>,
}

impl ClientModule for LnClient {
    const KIND: &'static str = "ln";
    type Module = LightningModuleTypes;

    fn decoder(&self) -> Decoder {
        <Self::Module as ModuleCommon>::decoder()
    }

    fn input_amount(&self, input: &LightningInput) -> TransactionItemAmount {
        TransactionItemAmount {
            amount: input.amount,
            fee: self.config.fee_consensus.contract_input,
        }
    }

    fn output_amount(&self, output: &LightningOutput) -> TransactionItemAmount {
        match output {
            LightningOutput::Contract(account_output) => TransactionItemAmount {
                amount: account_output.amount,
                fee: self.config.fee_consensus.contract_output,
            },
            LightningOutput::Offer(_) | LightningOutput::CancelOutgoing { .. } => {
                TransactionItemAmount {
                    amount: Amount::ZERO,
                    fee: Amount::ZERO,
                }
            }
        }
    }
}

#[allow(dead_code)]
impl LnClient {
    /// Create an output that incentivizes a Lighning gateway to pay an invoice
    /// for us. It has time till the block height defined by `timelock`,
    /// after that we can claim our money back.
    pub async fn create_outgoing_output<'a, 'b>(
        &'a self,
        dbtx: &mut DatabaseTransaction<'b>,
        invoice: Invoice,
        gateway: &LightningGateway,
        timelock: u32,
        mut rng: impl RngCore + CryptoRng + 'a,
    ) -> Result<LightningOutput> {
        let contract_amount = self.compute_outgoing_contract_amount(&invoice, gateway.fees)?;

        let user_sk = bitcoin::KeyPair::new(&self.context.secp, &mut rng);

        let contract = OutgoingContract {
            hash: *invoice.payment_hash(),
            gateway_key: gateway.gateway_redeem_key,
            timelock,
            user_key: user_sk.x_only_public_key().0,
            invoice,
            cancelled: false,
        };

        let outgoing_payment = OutgoingContractData {
            recovery_key: user_sk,
            contract_account: OutgoingContractAccount {
                amount: contract_amount,
                contract: contract.clone(),
            },
        };

        dbtx.insert_new_entry(
            &OutgoingPaymentKey(contract.contract_id()),
            &outgoing_payment,
        )
        .await;

        Ok(LightningOutput::Contract(ContractOutput {
            amount: contract_amount,
            contract: Contract::Outgoing(contract),
        }))
    }

    pub async fn get_contract_account(&self, id: ContractId) -> Result<ContractAccount> {
        timeout(Duration::from_secs(30), self.context.api.fetch_contract(id))
            .await
            .map_err(|_e| LnClientError::Timeout)?
            .map_err(LnClientError::ApiError)
    }

    pub async fn get_outgoing_contract(&self, id: ContractId) -> Result<OutgoingContractAccount> {
        let account = self.get_contract_account(id).await?;
        match account.contract {
            FundedContract::Outgoing(c) => Ok(OutgoingContractAccount {
                amount: account.amount,
                contract: c,
            }),
            _ => Err(LnClientError::WrongAccountType),
        }
    }

    /// Determines if an outgoing contract can be refunded
    pub async fn is_outgoing_contract_refundable(&self, id: ContractId) -> Result<bool> {
        let contract = self.get_outgoing_contract(id).await?;

        // If the contract was cancelled by the LN gateway we can get a refund instantly
        // …
        if contract.contract.cancelled {
            return Ok(true);
        }

        // … otherwise we have to wait till the timeout hits
        let consensus_block_height = self
            .context
            .api
            .fetch_consensus_block_height()
            .await
            .map_err(LnClientError::ApiError)?;
        if contract.contract.timelock as u64 <= consensus_block_height {
            return Ok(true);
        }

        Ok(false)
    }

    /// Waits for an outgoing contract to become refundable
    pub async fn await_outgoing_refundable(&self, id: ContractId) -> Result<()> {
        while !self.is_outgoing_contract_refundable(id).await? {
            crate::sleep(Duration::from_secs(1)).await;
        }
        Ok(())
    }

    pub async fn get_incoming_contract(&self, id: ContractId) -> Result<IncomingContractAccount> {
        let account = self.get_contract_account(id).await?;
        match account.contract {
            FundedContract::Incoming(c) => Ok(IncomingContractAccount {
                amount: account.amount,
                contract: c.contract,
            }),
            _ => Err(LnClientError::WrongAccountType),
        }
    }
    pub async fn refundable_outgoing_contracts(
        &self,
        block_height: u64,
    ) -> Vec<OutgoingContractData> {
        // TODO: unify block height type
        self.context
            .db
            .begin_transaction()
            .await
            .find_by_prefix(&OutgoingPaymentKeyPrefix)
            .await
            .filter_map(|(_, outgoing_data)| async {
                let cancelled = outgoing_data.contract_account.contract.cancelled;
                let timed_out =
                    outgoing_data.contract_account.contract.timelock as u64 <= block_height;
                if cancelled || timed_out {
                    Some(outgoing_data)
                } else {
                    None
                }
            })
            .collect::<Vec<OutgoingContractData>>()
            .await
    }

    pub fn create_refund_outgoing_contract_input<'a>(
        &self,
        contract_data: &'a OutgoingContractData,
    ) -> (&'a bitcoin::KeyPair, LightningInput) {
        (
            &contract_data.recovery_key,
            contract_data.contract_account.refund(),
        )
    }

    pub fn create_offer_output(
        &self,
        amount: Amount,
        payment_hash: Sha256Hash,
        payment_secret: Preimage,
        expiry_time: Option<u64>,
    ) -> LightningOutput {
        LightningOutput::Offer(IncomingContractOffer {
            amount,
            hash: payment_hash,
            encrypted_preimage: EncryptedPreimage::new(
                payment_secret,
                &self.config.threshold_pub_key,
            ),
            expiry_time,
        })
    }

    pub async fn get_offer(&self, payment_hash: Sha256Hash) -> Result<IncomingContractOffer> {
        timeout(
            Duration::from_secs(10),
            self.context.api.fetch_offer(payment_hash),
        )
        .await
        .map_err(|_e| LnClientError::Timeout)?
        .map_err(LnClientError::ApiError)
    }

    pub async fn offer_exists(&self, payment_hash: Sha256Hash) -> Result<bool> {
        self.context
            .api
            .offer_exists(payment_hash)
            .await
            .map_err(LnClientError::ApiError)
    }

    pub async fn save_confirmed_invoice(&self, invoice: &ConfirmedInvoice) {
        let mut dbtx = self.context.db.begin_transaction().await;
        dbtx.insert_entry(&ConfirmedInvoiceKey(invoice.contract_id()), invoice)
            .await;
        dbtx.commit_tx().await;
    }

    pub async fn get_confirmed_invoice(&self, contract_id: ContractId) -> Result<ConfirmedInvoice> {
        let confirmed_invoice = self
            .context
            .db
            .begin_transaction()
            .await
            .get_value(&ConfirmedInvoiceKey(contract_id))
            .await
            .ok_or(LnClientError::NoConfirmedInvoice(contract_id))?;
        Ok(confirmed_invoice)
    }

    /// Used by gateway to prematurely return funds to the user if the payment
    /// failed
    pub fn create_cancel_outgoing_output(
        &self,
        contract_id: ContractId,
        signature: secp256k1_zkp::schnorr::Signature,
    ) -> LightningOutput {
        LightningOutput::CancelOutgoing {
            contract: contract_id,
            gateway_signature: signature,
        }
    }

    pub fn compute_outgoing_contract_amount(
        &self,
        invoice: &Invoice,
        fees: RoutingFees,
    ) -> Result<Amount> {
        let invoice_amount_msat = invoice
            .amount_milli_satoshis()
            .ok_or(LnClientError::MissingInvoiceAmount)?;

        let base_fee = fees.base_msat as u64;
        let margin_fee: u64 = if fees.proportional_millionths > 0 {
            let fee_percent = 1000000 / fees.proportional_millionths as u64;
            invoice_amount_msat / fee_percent
        } else {
            0
        };

        // Add base and margin routing fees
        let contract_amount_msat = invoice_amount_msat + base_fee + margin_fee;

        Ok(Amount::from_msats(contract_amount_msat))
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct PayInvoicePayload {
    pub federation_id: FederationId,
    pub contract_id: ContractId,
}

impl PayInvoicePayload {
    pub fn new(federation_id: FederationId, contract_id: ContractId) -> Self {
        Self {
            contract_id,
            federation_id,
        }
    }
}

pub type Result<T> = std::result::Result<T, LnClientError>;

#[derive(Debug, Error)]
pub enum LnClientError {
    #[error("We can't pay an amountless invoice")]
    MissingInvoiceAmount,
    #[error("Mint API error: {0}")]
    ApiError(FederationError),
    #[error("Timeout")]
    Timeout,
    #[error("Mint returned unexpected account type")]
    WrongAccountType,
    #[error("No ConfirmedOffer found for contract ID {0}")]
    NoConfirmedInvoice(ContractId),
}


