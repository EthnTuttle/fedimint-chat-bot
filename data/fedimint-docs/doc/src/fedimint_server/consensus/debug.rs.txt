logo [../../../static.files/rust-logo-151179464ae7ed46.svg]../../../fedimint_server/index.html
? [../../../help.html]
Change settings [../../../static.files/wheel-5ec35bf9ca753509.svg]../../../settings.html

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44


use std::fmt::Write;

use fedimint_core::transaction::Transaction;

use crate::{ConsensusItem, HbbftConsensusOutcome};

/// outputs a useful debug message for epochs indicating what happened
pub fn epoch_message(consensus: &HbbftConsensusOutcome) -> String {
    let peers = consensus.contributions.keys();
    let mut debug = format!("\n- Epoch: {} {:?} -", consensus.epoch, peers);

    for (peer, items) in consensus.contributions.iter() {
        for item in items {
            let item_debug = item_message(item);
            write!(debug, "\n  Peer {peer}: {item_debug}").unwrap();
        }
    }
    debug
}

fn item_message(item: &ConsensusItem) -> String {
    match item {
        ConsensusItem::EpochOutcomeSignatureShare(_) => "Outcome Signature".to_string(),
        ConsensusItem::ClientConfigSignatureShare(_) => "Client Config Signature".to_string(),
        // TODO: make this nice again
        ConsensusItem::Module(mci) => {
            format!("Module CI: module={} ci={}", mci.module_instance_id(), mci)
        }
        ConsensusItem::Transaction(Transaction {
            inputs, outputs, ..
        }) => {
            let mut tx_debug = "Transaction".to_string();
            for input in inputs.iter() {
                // TODO: add pretty print fn to interface
                write!(tx_debug, "\n    Input: {input}").unwrap();
            }
            for output in outputs.iter() {
                write!(tx_debug, "\n    Output: {output}").unwrap();
            }
            tx_debug
        }
        ConsensusItem::ConsensusUpgrade(_) => "Consensus Upgrade".to_string(),
    }
}


