☰
logo [../static.files/rust-logo-151179464ae7ed46.svg]
../fedimint_ln_server/index.html




logo [../static.files/rust-logo-151179464ae7ed46.svg]
../fedimint_ln_server/index.html


AMOUNTS_BUCKETS_SATS


METHODS FROM DEREF<TARGET=VEC<F64>>

 * allocator
 * as_ptr
 * as_slice
 * capacity
 * is_empty
 * len


METHODS FROM DEREF<TARGET=[T]>

 * align_to
 * align_to_mut
 * array_chunks
 * array_chunks_mut
 * array_windows
 * as_chunks
 * as_chunks_mut
 * as_chunks_unchecked
 * as_chunks_unchecked_mut
 * as_mut_ptr
 * as_mut_ptr_range
 * as_ptr
 * as_ptr_range
 * as_rchunks
 * as_rchunks_mut
 * as_simd
 * as_simd_mut
 * binary_search
 * binary_search_by
 * binary_search_by_key
 * chunks
 * chunks_exact
 * chunks_exact_mut
 * chunks_mut
 * clone_from_slice
 * concat
 * connect
 * contains
 * copy_from_slice
 * copy_within
 * ends_with
 * eq_ignore_ascii_case
 * escape_ascii
 * fill
 * fill_with
 * first
 * first_mut
 * flatten
 * flatten_mut
 * get
 * get_many_mut
 * get_many_unchecked_mut
 * get_mut
 * get_unchecked
 * get_unchecked_mut
 * group_by
 * group_by_mut
 * is_ascii
 * is_empty
 * is_sorted
 * is_sorted_by
 * is_sorted_by_key
 * iter
 * iter_mut
 * join
 * last
 * last_mut
 * len
 * make_ascii_lowercase
 * make_ascii_uppercase
 * partition_dedup
 * partition_dedup_by
 * partition_dedup_by_key
 * partition_point
 * rchunks
 * rchunks_exact
 * rchunks_exact_mut
 * rchunks_mut
 * repeat
 * reverse
 * rotate_left
 * rotate_right
 * rsplit
 * rsplit_array_mut
 * rsplit_array_ref
 * rsplit_mut
 * rsplitn
 * rsplitn_mut
 * select_nth_unstable
 * select_nth_unstable_by
 * select_nth_unstable_by_key
 * sort
 * sort_by
 * sort_by_cached_key
 * sort_by_key
 * sort_floats
 * sort_floats
 * sort_unstable
 * sort_unstable_by
 * sort_unstable_by_key
 * split
 * split_array_mut
 * split_array_ref
 * split_at
 * split_at_mut
 * split_at_mut_unchecked
 * split_at_unchecked
 * split_first
 * split_first_mut
 * split_inclusive
 * split_inclusive_mut
 * split_last
 * split_last_mut
 * split_mut
 * splitn
 * splitn_mut
 * starts_with
 * strip_prefix
 * strip_suffix
 * swap
 * swap_unchecked
 * swap_with_slice
 * take
 * take_first
 * take_first_mut
 * take_last
 * take_last_mut
 * take_mut
 * to_ascii_lowercase
 * to_ascii_uppercase
 * to_vec
 * to_vec_in
 * trim_ascii
 * trim_ascii_end
 * trim_ascii_start
 * windows


TRAIT IMPLEMENTATIONS

 * Deref
 * LazyStatic


AUTO TRAIT IMPLEMENTATIONS

 * RefUnwindSafe
 * Send
 * Sync
 * Unpin
 * UnwindSafe


BLANKET IMPLEMENTATIONS

 * Any
 * Borrow<T>
 * BorrowMut<T>
 * Conv
 * FmtForward
 * From<T>
 * FutureExt
 * Instrument
 * Into<U>
 * IntoRequest<T>
 * MaybeSend
 * MaybeSend
 * MaybeSync
 * Pipe
 * Same<T>
 * Tap
 * TryConv
 * TryFrom<U>
 * TryInto<U>
 * VZip<V>
 * WithSubscriber


IN FEDIMINT_LN_SERVER [index.html]

? [../help.html]
Change settings [../static.files/wheel-5ec35bf9ca753509.svg]../settings.html


STRUCT FEDIMINT_LN_SERVER [index.html]::AMOUNTS_BUCKETS_SATSCopy item path [../static.files/clipboard-7571035ce49a181d.svg]

source [../src/fedimint_ln_server/lib.rs.html#57-102] · [−]

pub struct AMOUNTS_BUCKETS_SATS { /* private fields */ }


METHODS FROM DEREF [https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.Deref.html]<TARGET = VEC
[https://doc.rust-lang.org/1.67.0/alloc/vec/struct.Vec.html]<F64 [https://doc.rust-lang.org/1.67.0/std/primitive.f64.html]>>§

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/vec/mod.rs.html#883]

PUB FN CAPACITY(&SELF) -> USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]

Returns the total number of elements the vector can hold without reallocating.

EXAMPLES

let mut vec: Vec<i32> = Vec::with_capacity(10);
vec.push(42);
assert_eq!(vec.capacity(), 10);

1.7.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/vec/mod.rs.html#1186]

PUB FN AS_SLICE(&SELF) -> &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html] Ⓘ

Extracts a slice containing the entire vector.

Equivalent to &s[..].

EXAMPLES

use std::io::{self, Write};
let buffer = vec![1, 2, 3, 5, 8];
io::sink().write(buffer.as_slice()).unwrap();

1.37.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/vec/mod.rs.html#1235]

PUB FN AS_PTR(&SELF) -> *CONST T [https://doc.rust-lang.org/1.67.0/std/primitive.pointer.html]

Returns a raw pointer to the vector’s buffer, or a dangling raw pointer valid for zero sized reads if the vector didn’t allocate.

The caller must ensure that the vector outlives the pointer this function returns, or else it will end up pointing to garbage.
Modifying the vector may cause its buffer to be reallocated, which would also make any pointers to it invalid.

The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an
UnsafeCell) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use as_mut_ptr
[https://doc.rust-lang.org/1.67.0/alloc/vec/struct.Vec.html#method.as_mut_ptr].

EXAMPLES

let x = vec![1, 2, 4];
let x_ptr = x.as_ptr();

unsafe {
    for i in 0..x.len() {
        assert_eq!(*x_ptr.add(i), 1 << i);
    }
}

source [https://doc.rust-lang.org/1.67.0/src/alloc/vec/mod.rs.html#1285]

PUB FN ALLOCATOR(&SELF) -> & [https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]A

🔬This is a nightly-only experimental API. (allocator_api)

Returns a reference to the underlying allocator.

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/vec/mod.rs.html#2056]

PUB FN LEN(&SELF) -> USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]

Returns the number of elements in the vector, also referred to as its ‘length’.

EXAMPLES

let a = vec![1, 2, 3];
assert_eq!(a.len(), 3);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/vec/mod.rs.html#2072]

PUB FN IS_EMPTY(&SELF) -> BOOL [https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]

Returns true if the vector contains no elements.

EXAMPLES

let mut v = Vec::new();
assert!(v.is_empty());

v.push(1);
assert!(!v.is_empty());


METHODS FROM DEREF [https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.Deref.html]<TARGET = [T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>§

1.23.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/ascii.rs.html#15]

PUB FN IS_ASCII(&SELF) -> BOOL [https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]

Checks if all bytes in this slice are within the ASCII range.

1.23.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/ascii.rs.html#26]

PUB FN EQ_IGNORE_ASCII_CASE(&SELF, OTHER: &[U8 [https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]]) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]

Checks that two slices are an ASCII case-insensitive match.

Same as to_ascii_lowercase(a) == to_ascii_lowercase(b), but without allocating and copying temporaries.

1.23.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/ascii.rs.html#41]

PUB FN MAKE_ASCII_UPPERCASE(&MUT SELF)

Converts this slice to its ASCII upper case equivalent in-place.

ASCII letters ‘a’ to ‘z’ are mapped to ‘A’ to ‘Z’, but non-ASCII letters are unchanged.

To return a new uppercased value without modifying the existing one, use to_ascii_uppercase.

1.23.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/ascii.rs.html#58]

PUB FN MAKE_ASCII_LOWERCASE(&MUT SELF)

Converts this slice to its ASCII lower case equivalent in-place.

ASCII letters ‘A’ to ‘Z’ are mapped to ‘a’ to ‘z’, but non-ASCII letters are unchanged.

To return a new lowercased value without modifying the existing one, use to_ascii_lowercase.

1.60.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/ascii.rs.html#78]

PUB FN ESCAPE_ASCII(&SELF) -> ESCAPEASCII [https://doc.rust-lang.org/1.67.0/core/slice/ascii/struct.EscapeAscii.html]<'_>

Returns an iterator that produces an escaped version of this slice, treating it as an ASCII string.

EXAMPLES


let s = b"0\t\r\n'\"\\\x9d";
let escaped = s.escape_ascii().to_string();
assert_eq!(escaped, "0\\t\\r\\n\\'\\\"\\\\\\x9d");

source [https://doc.rust-lang.org/1.67.0/src/core/slice/ascii.rs.html#97]

PUB FN TRIM_ASCII_START(&SELF) -> &[U8 [https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]] Ⓘ

🔬This is a nightly-only experimental API. (byte_slice_trim_ascii)

Returns a byte slice with leading ASCII whitespace bytes removed.

‘Whitespace’ refers to the definition used by u8::is_ascii_whitespace.

EXAMPLES

#![feature(byte_slice_trim_ascii)]

assert_eq!(b" \t hello world\n".trim_ascii_start(), b"hello world\n");
assert_eq!(b"  ".trim_ascii_start(), b"");
assert_eq!(b"".trim_ascii_start(), b"");

source [https://doc.rust-lang.org/1.67.0/src/core/slice/ascii.rs.html#126]

PUB FN TRIM_ASCII_END(&SELF) -> &[U8 [https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]] Ⓘ

🔬This is a nightly-only experimental API. (byte_slice_trim_ascii)

Returns a byte slice with trailing ASCII whitespace bytes removed.

‘Whitespace’ refers to the definition used by u8::is_ascii_whitespace.

EXAMPLES

#![feature(byte_slice_trim_ascii)]

assert_eq!(b"\r hello world\n ".trim_ascii_end(), b"\r hello world");
assert_eq!(b"  ".trim_ascii_end(), b"");
assert_eq!(b"".trim_ascii_end(), b"");

source [https://doc.rust-lang.org/1.67.0/src/core/slice/ascii.rs.html#156]

PUB FN TRIM_ASCII(&SELF) -> &[U8 [https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]] Ⓘ

🔬This is a nightly-only experimental API. (byte_slice_trim_ascii)

Returns a byte slice with leading and trailing ASCII whitespace bytes removed.

‘Whitespace’ refers to the definition used by u8::is_ascii_whitespace.

EXAMPLES

#![feature(byte_slice_trim_ascii)]

assert_eq!(b"\r hello world\n ".trim_ascii(), b"hello world");
assert_eq!(b"  ".trim_ascii(), b"");
assert_eq!(b"".trim_ascii(), b"");

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#4202]

PUB FN FLATTEN(&SELF) -> &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html] Ⓘ

🔬This is a nightly-only experimental API. (slice_flatten)

Takes a &[[T; N]], and flattens it to a &[T].

PANICS

This panics if the length of the resulting slice would overflow a usize.

This is only possible when flattening a slice of arrays of zero-sized types, and thus tends to be irrelevant in practice. If
size_of::<T>() > 0, this will never panic.

EXAMPLES

#![feature(slice_flatten)]

assert_eq!([[1, 2, 3], [4, 5, 6]].flatten(), &[1, 2, 3, 4, 5, 6]);

assert_eq!(
    [[1, 2, 3], [4, 5, 6]].flatten(),
    [[1, 2], [3, 4], [5, 6]].flatten(),
);

let slice_of_empty_arrays: &[[i32; 0]] = &[[], [], [], [], []];
assert!(slice_of_empty_arrays.flatten().is_empty());

let empty_slice_of_arrays: &[[u32; 10]] = &[];
assert!(empty_slice_of_arrays.flatten().is_empty());

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#4240]

PUB FN FLATTEN_MUT(&MUT SELF) -> &MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html] Ⓘ

🔬This is a nightly-only experimental API. (slice_flatten)

Takes a &mut [[T; N]], and flattens it to a &mut [T].

PANICS

This panics if the length of the resulting slice would overflow a usize.

This is only possible when flattening a slice of arrays of zero-sized types, and thus tends to be irrelevant in practice. If
size_of::<T>() > 0, this will never panic.

EXAMPLES

#![feature(slice_flatten)]

fn add_5_to_all(slice: &mut [i32]) {
    for i in slice {
        *i += 5;
    }
}

let mut array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
add_5_to_all(array.flatten_mut());
assert_eq!(array, [[6, 7, 8], [9, 10, 11], [12, 13, 14]]);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#4306]

PUB FN SORT_FLOATS(&MUT SELF)

🔬This is a nightly-only experimental API. (sort_floats)

Sorts the slice of floats.

This sort is in-place (i.e. does not allocate), O(n * log(n)) worst-case, and uses the ordering defined by f64::total_cmp
[https://doc.rust-lang.org/1.67.0/std/primitive.f64.html#method.total_cmp].

CURRENT IMPLEMENTATION

This uses the same sorting algorithm as sort_unstable_by
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.sort_unstable_by].

EXAMPLES

#![feature(sort_floats)]
let mut v = [2.6, -5e-8, f64::NAN, 8.29, f64::INFINITY, -1.0, 0.0, -f64::INFINITY, -0.0];

v.sort_floats();
let sorted = [-f64::INFINITY, -1.0, -5e-8, -0.0, 0.0, 2.6, 8.29, f64::INFINITY, f64::NAN];
assert_eq!(&v[..8], &sorted[..8]);
assert!(v[8].is_nan());

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#130]

PUB FN LEN(&SELF) -> USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]

Returns the number of elements in the slice.

EXAMPLES

let a = [1, 2, 3];
assert_eq!(a.len(), 3);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#146]

PUB FN IS_EMPTY(&SELF) -> BOOL [https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]

Returns true if the slice has a length of 0.

EXAMPLES

let a = [1, 2, 3];
assert!(!a.is_empty());

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#165]

PUB FN FIRST(&SELF) -> OPTION [https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T>

Returns the first element of the slice, or None if it is empty.

EXAMPLES

let v = [10, 40, 30];
assert_eq!(Some(&10), v.first());

let w: &[i32] = &[];
assert_eq!(None, w.first());

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#185]

PUB FN FIRST_MUT(&MUT SELF) -> OPTION [https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T>

Returns a mutable pointer to the first element of the slice, or None if it is empty.

EXAMPLES

let x = &mut [0, 1, 2];

if let Some(first) = x.first_mut() {
    *first = 5;
}
assert_eq!(x, &[5, 1, 2]);

1.5.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#205]

PUB FN SPLIT_FIRST(&SELF) -> OPTION [https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<(&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T, &[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])>

Returns the first and all the rest of the elements of the slice, or None if it is empty.

EXAMPLES

let x = &[0, 1, 2];

if let Some((first, elements)) = x.split_first() {
    assert_eq!(first, &0);
    assert_eq!(elements, &[1, 2]);
}

1.5.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#227]

PUB FN SPLIT_FIRST_MUT(&MUT SELF) -> OPTION [https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<(&MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T, &MUT [T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])>

Returns the first and all the rest of the elements of the slice, or None if it is empty.

EXAMPLES

let x = &mut [0, 1, 2];

if let Some((first, elements)) = x.split_first_mut() {
    *first = 3;
    elements[0] = 4;
    elements[1] = 5;
}
assert_eq!(x, &[3, 4, 5]);

1.5.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#247]

PUB FN SPLIT_LAST(&SELF) -> OPTION [https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<(&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T, &[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])>

Returns the last and all the rest of the elements of the slice, or None if it is empty.

EXAMPLES

let x = &[0, 1, 2];

if let Some((last, elements)) = x.split_last() {
    assert_eq!(last, &2);
    assert_eq!(elements, &[0, 1]);
}

1.5.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#269]

PUB FN SPLIT_LAST_MUT(&MUT SELF) -> OPTION [https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<(&MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T, &MUT [T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])>

Returns the last and all the rest of the elements of the slice, or None if it is empty.

EXAMPLES

let x = &mut [0, 1, 2];

if let Some((last, elements)) = x.split_last_mut() {
    *last = 3;
    elements[0] = 4;
    elements[1] = 5;
}
assert_eq!(x, &[4, 5, 3]);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#288]

PUB FN LAST(&SELF) -> OPTION [https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T>

Returns the last element of the slice, or None if it is empty.

EXAMPLES

let v = [10, 40, 30];
assert_eq!(Some(&30), v.last());

let w: &[i32] = &[];
assert_eq!(None, w.last());

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#308]

PUB FN LAST_MUT(&MUT SELF) -> OPTION [https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T>

Returns a mutable pointer to the last item in the slice.

EXAMPLES

let x = &mut [0, 1, 2];

if let Some(last) = x.last_mut() {
    *last = 10;
}
assert_eq!(x, &[0, 1, 10]);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#333-335]

PUB FN GET<I>(&SELF, INDEX: I) -> OPTION [https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&<I AS SLICEINDEX
[https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html]<[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>>::OUTPUT
[https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html#associatedtype.Output]>WHERE
    I: SLICEINDEX [https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html]<[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>,

Returns a reference to an element or subslice depending on the type of index.

 * If given a position, returns a reference to the element at that position or None if out of bounds.
 * If given a range, returns the subslice corresponding to that range, or None if out of bounds.

EXAMPLES

let v = [10, 40, 30];
assert_eq!(Some(&40), v.get(1));
assert_eq!(Some(&[10, 40][..]), v.get(0..2));
assert_eq!(None, v.get(3));
assert_eq!(None, v.get(0..4));

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#359-361]

PUB FN GET_MUT<I>(
    &MUT SELF,
    INDEX: I
) -> OPTION [https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&MUT <I AS SLICEINDEX
[https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html]<[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>>::OUTPUT
[https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html#associatedtype.Output]>WHERE
    I: SLICEINDEX [https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html]<[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>,

Returns a mutable reference to an element or subslice depending on the type of index (see get
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.get]) or None if the index is out of bounds.

EXAMPLES

let x = &mut [0, 1, 2];

if let Some(elem) = x.get_mut(1) {
    *elem = 42;
}
assert_eq!(x, &[0, 42, 2]);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#392-394]

PUB UNSAFE FN GET_UNCHECKED<I>(
    &SELF,
    INDEX: I
) -> &<I AS SLICEINDEX [https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html]<[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>>::OUTPUT
[https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html#associatedtype.Output]WHERE
    I: SLICEINDEX [https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html]<[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>,

Returns a reference to an element or subslice, without doing bounds checking.

For a safe alternative see get [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.get].

SAFETY

Calling this method with an out-of-bounds index is undefined behavior
[https://doc.rust-lang.org/reference/behavior-considered-undefined.html] even if the resulting reference is not used.

EXAMPLES

let x = &[1, 2, 4];

unsafe {
    assert_eq!(x.get_unchecked(1), &2);
}

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#430-432]

PUB UNSAFE FN GET_UNCHECKED_MUT<I>(
    &MUT SELF,
    INDEX: I
) -> &MUT <I AS SLICEINDEX [https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html]<[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>>::OUTPUT
[https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html#associatedtype.Output]WHERE
    I: SLICEINDEX [https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html]<[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>,

Returns a mutable reference to an element or subslice, without doing bounds checking.

For a safe alternative see get_mut [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.get_mut].

SAFETY

Calling this method with an out-of-bounds index is undefined behavior
[https://doc.rust-lang.org/reference/behavior-considered-undefined.html] even if the resulting reference is not used.

EXAMPLES

let x = &mut [1, 2, 4];

unsafe {
    let elem = x.get_unchecked_mut(1);
    *elem = 13;
}
assert_eq!(x, &[1, 13, 4]);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#470]

PUB FN AS_PTR(&SELF) -> *CONST T [https://doc.rust-lang.org/1.67.0/std/primitive.pointer.html]

Returns a raw pointer to the slice’s buffer.

The caller must ensure that the slice outlives the pointer this function returns, or else it will end up pointing to garbage.

The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an
UnsafeCell) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use as_mut_ptr
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.as_mut_ptr].

Modifying the container referenced by this slice may cause its buffer to be reallocated, which would also make any pointers to it
invalid.

EXAMPLES

let x = &[1, 2, 4];
let x_ptr = x.as_ptr();

unsafe {
    for i in 0..x.len() {
        assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));
    }
}

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#500]

PUB FN AS_MUT_PTR(&MUT SELF) -> *MUT T [https://doc.rust-lang.org/1.67.0/std/primitive.pointer.html]

Returns an unsafe mutable pointer to the slice’s buffer.

The caller must ensure that the slice outlives the pointer this function returns, or else it will end up pointing to garbage.

Modifying the container referenced by this slice may cause its buffer to be reallocated, which would also make any pointers to it
invalid.

EXAMPLES

let x = &mut [1, 2, 4];
let x_ptr = x.as_mut_ptr();

unsafe {
    for i in 0..x.len() {
        *x_ptr.add(i) += 2;
    }
}
assert_eq!(x, &[3, 4, 6]);

1.48.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#536]

PUB FN AS_PTR_RANGE(&SELF) -> RANGE [https://doc.rust-lang.org/1.67.0/core/ops/range/struct.Range.html]<*CONST T
[https://doc.rust-lang.org/1.67.0/std/primitive.pointer.html]>

Returns the two raw pointers spanning the slice.

The returned range is half-open, which means that the end pointer points one past the last element of the slice. This way, an
empty slice is represented by two equal pointers, and the difference between the two pointers represents the size of the slice.

See as_ptr [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.as_ptr] for warnings on using these pointers. The end
pointer requires extra caution, as it does not point to a valid element in the slice.

This function is useful for interacting with foreign interfaces which use two pointers to refer to a range of elements in memory,
as is common in C++.

It can also be useful to check if a pointer to an element refers to an element of this slice:

let a = [1, 2, 3];
let x = &a[1] as *const _;
let y = &5 as *const _;

assert!(a.as_ptr_range().contains(&x));
assert!(!a.as_ptr_range().contains(&y));

1.48.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#580]

PUB FN AS_MUT_PTR_RANGE(&MUT SELF) -> RANGE [https://doc.rust-lang.org/1.67.0/core/ops/range/struct.Range.html]<*MUT T
[https://doc.rust-lang.org/1.67.0/std/primitive.pointer.html]>

Returns the two unsafe mutable pointers spanning the slice.

The returned range is half-open, which means that the end pointer points one past the last element of the slice. This way, an
empty slice is represented by two equal pointers, and the difference between the two pointers represents the size of the slice.

See as_mut_ptr [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.as_mut_ptr] for warnings on using these pointers.
The end pointer requires extra caution, as it does not point to a valid element in the slice.

This function is useful for interacting with foreign interfaces which use two pointers to refer to a range of elements in memory,
as is common in C++.

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#609]

PUB FN SWAP(&MUT SELF, A: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html], B: USIZE
[https://doc.rust-lang.org/1.67.0/std/primitive.usize.html])

Swaps two elements in the slice.

ARGUMENTS

 * a - The index of the first element
 * b - The index of the second element

PANICS

Panics if a or b are out of bounds.

EXAMPLES

let mut v = ["a", "b", "c", "d", "e"];
v.swap(2, 4);
assert!(v == ["a", "b", "e", "d", "c"]);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#652]

PUB UNSAFE FN SWAP_UNCHECKED(&MUT SELF, A: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html], B: USIZE
[https://doc.rust-lang.org/1.67.0/std/primitive.usize.html])

🔬This is a nightly-only experimental API. (slice_swap_unchecked)

Swaps two elements in the slice, without doing bounds checking.

For a safe alternative see swap [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.swap].

ARGUMENTS

 * a - The index of the first element
 * b - The index of the second element

SAFETY

Calling this method with an out-of-bounds index is undefined behavior
[https://doc.rust-lang.org/reference/behavior-considered-undefined.html]. The caller has to ensure that a < self.len() and b <
self.len().

EXAMPLES

#![feature(slice_swap_unchecked)]

let mut v = ["a", "b", "c", "d"];
// SAFETY: we know that 1 and 3 are both indices of the slice
unsafe { v.swap_unchecked(1, 3) };
assert!(v == ["a", "d", "c", "b"]);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#677]

PUB FN REVERSE(&MUT SELF)

Reverses the order of elements in the slice, in place.

EXAMPLES

let mut v = [1, 2, 3];
v.reverse();
assert!(v == [3, 2, 1]);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#735]

PUB FN ITER(&SELF) -> ITER [https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.Iter.html]<'_, T>

Returns an iterator over the slice.

The iterator yields all items from start to end.

EXAMPLES

let x = &[1, 2, 4];
let mut iterator = x.iter();

assert_eq!(iterator.next(), Some(&1));
assert_eq!(iterator.next(), Some(&2));
assert_eq!(iterator.next(), Some(&4));
assert_eq!(iterator.next(), None);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#754]

PUB FN ITER_MUT(&MUT SELF) -> ITERMUT [https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.IterMut.html]<'_, T>

Returns an iterator that allows modifying each value.

The iterator yields all items from start to end.

EXAMPLES

let x = &mut [1, 2, 4];
for elem in x.iter_mut() {
    *elem += 2;
}
assert_eq!(x, &[3, 4, 6]);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#786]

PUB FN WINDOWS(&SELF, SIZE: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> WINDOWS
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.Windows.html]<'_, T>

Returns an iterator over all contiguous windows of length size. The windows overlap. If the slice is shorter than size, the
iterator returns no values.

PANICS

Panics if size is 0.

EXAMPLES

let slice = ['r', 'u', 's', 't'];
let mut iter = slice.windows(2);
assert_eq!(iter.next().unwrap(), &['r', 'u']);
assert_eq!(iter.next().unwrap(), &['u', 's']);
assert_eq!(iter.next().unwrap(), &['s', 't']);
assert!(iter.next().is_none());

If the slice is shorter than size:

let slice = ['f', 'o', 'o'];
let mut iter = slice.windows(4);
assert!(iter.next().is_none());

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#820]

PUB FN CHUNKS(&SELF, CHUNK_SIZE: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> CHUNKS
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.Chunks.html]<'_, T>

Returns an iterator over chunk_size elements of the slice at a time, starting at the beginning of the slice.

The chunks are slices and do not overlap. If chunk_size does not divide the length of the slice, then the last chunk will not have
length chunk_size.

See chunks_exact [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks_exact] for a variant of this iterator
that returns chunks of always exactly chunk_size elements, and rchunks
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.rchunks] for the same iterator but starting at the end of the
slice.

PANICS

Panics if chunk_size is 0.

EXAMPLES

let slice = ['l', 'o', 'r', 'e', 'm'];
let mut iter = slice.chunks(2);
assert_eq!(iter.next().unwrap(), &['l', 'o']);
assert_eq!(iter.next().unwrap(), &['r', 'e']);
assert_eq!(iter.next().unwrap(), &['m']);
assert!(iter.next().is_none());

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#858]

PUB FN CHUNKS_MUT(&MUT SELF, CHUNK_SIZE: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> CHUNKSMUT
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.ChunksMut.html]<'_, T>

Returns an iterator over chunk_size elements of the slice at a time, starting at the beginning of the slice.

The chunks are mutable slices, and do not overlap. If chunk_size does not divide the length of the slice, then the last chunk will
not have length chunk_size.

See chunks_exact_mut [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks_exact_mut] for a variant of this
iterator that returns chunks of always exactly chunk_size elements, and rchunks_mut
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.rchunks_mut] for the same iterator but starting at the end of
the slice.

PANICS

Panics if chunk_size is 0.

EXAMPLES

let v = &mut [0, 0, 0, 0, 0];
let mut count = 1;

for chunk in v.chunks_mut(2) {
    for elem in chunk.iter_mut() {
        *elem += count;
    }
    count += 1;
}
assert_eq!(v, &[1, 1, 2, 2, 3]);

1.31.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#895]

PUB FN CHUNKS_EXACT(&SELF, CHUNK_SIZE: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> CHUNKSEXACT
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.ChunksExact.html]<'_, T>

Returns an iterator over chunk_size elements of the slice at a time, starting at the beginning of the slice.

The chunks are slices and do not overlap. If chunk_size does not divide the length of the slice, then the last up to chunk_size-1
elements will be omitted and can be retrieved from the remainder function of the iterator.

Due to each chunk having exactly chunk_size elements, the compiler can often optimize the resulting code better than in the case
of chunks [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks].

See chunks [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks] for a variant of this iterator that also
returns the remainder as a smaller chunk, and rchunks_exact
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.rchunks_exact] for the same iterator but starting at the end of
the slice.

PANICS

Panics if chunk_size is 0.

EXAMPLES

let slice = ['l', 'o', 'r', 'e', 'm'];
let mut iter = slice.chunks_exact(2);
assert_eq!(iter.next().unwrap(), &['l', 'o']);
assert_eq!(iter.next().unwrap(), &['r', 'e']);
assert!(iter.next().is_none());
assert_eq!(iter.remainder(), &['m']);

1.31.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#937]

PUB FN CHUNKS_EXACT_MUT(&MUT SELF, CHUNK_SIZE: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) ->
CHUNKSEXACTMUT [https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.ChunksExactMut.html]<'_, T>

Returns an iterator over chunk_size elements of the slice at a time, starting at the beginning of the slice.

The chunks are mutable slices, and do not overlap. If chunk_size does not divide the length of the slice, then the last up to
chunk_size-1 elements will be omitted and can be retrieved from the into_remainder function of the iterator.

Due to each chunk having exactly chunk_size elements, the compiler can often optimize the resulting code better than in the case
of chunks_mut [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks_mut].

See chunks_mut [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks_mut] for a variant of this iterator that
also returns the remainder as a smaller chunk, and rchunks_exact_mut
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.rchunks_exact_mut] for the same iterator but starting at the end
of the slice.

PANICS

Panics if chunk_size is 0.

EXAMPLES

let v = &mut [0, 0, 0, 0, 0];
let mut count = 1;

for chunk in v.chunks_exact_mut(2) {
    for elem in chunk.iter_mut() {
        *elem += count;
    }
    count += 1;
}
assert_eq!(v, &[1, 1, 2, 2, 0]);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#972]

PUB UNSAFE FN AS_CHUNKS_UNCHECKED<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&SELF) -> &[[T; N]
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html]]

🔬This is a nightly-only experimental API. (slice_as_chunks)

Splits the slice into a slice of N-element arrays, assuming that there’s no remainder.

SAFETY

This may only be called when

 * The slice splits exactly into N-element chunks (aka self.len() % N == 0).
 * N != 0.

EXAMPLES

#![feature(slice_as_chunks)]
let slice: &[char] = &['l', 'o', 'r', 'e', 'm', '!'];
let chunks: &[[char; 1]] =
    // SAFETY: 1-element chunks never have remainder
    unsafe { slice.as_chunks_unchecked() };
assert_eq!(chunks, &[['l'], ['o'], ['r'], ['e'], ['m'], ['!']]);
let chunks: &[[char; 3]] =
    // SAFETY: The slice length (6) is a multiple of 3
    unsafe { slice.as_chunks_unchecked() };
assert_eq!(chunks, &[['l', 'o', 'r'], ['e', 'm', '!']]);

// These would be unsound:
// let chunks: &[[_; 5]] = slice.as_chunks_unchecked() // The slice length is not a multiple of 5
// let chunks: &[[_; 0]] = slice.as_chunks_unchecked() // Zero-length chunks are never allowed

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1008]

PUB FN AS_CHUNKS<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&SELF) -> (&[[T; N]
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html]], &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])

🔬This is a nightly-only experimental API. (slice_as_chunks)

Splits the slice into a slice of N-element arrays, starting at the beginning of the slice, and a remainder slice with length
strictly less than N.

PANICS

Panics if N is 0. This check will most probably get changed to a compile time error before this method gets stabilized.

EXAMPLES

#![feature(slice_as_chunks)]
let slice = ['l', 'o', 'r', 'e', 'm'];
let (chunks, remainder) = slice.as_chunks();
assert_eq!(chunks, &[['l', 'o'], ['r', 'e']]);
assert_eq!(remainder, &['m']);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1039]

PUB FN AS_RCHUNKS<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&SELF) -> (&[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &[[T; N]
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html]])

🔬This is a nightly-only experimental API. (slice_as_chunks)

Splits the slice into a slice of N-element arrays, starting at the end of the slice, and a remainder slice with length strictly
less than N.

PANICS

Panics if N is 0. This check will most probably get changed to a compile time error before this method gets stabilized.

EXAMPLES

#![feature(slice_as_chunks)]
let slice = ['l', 'o', 'r', 'e', 'm'];
let (remainder, chunks) = slice.as_rchunks();
assert_eq!(remainder, &['l']);
assert_eq!(chunks, &[['o', 'r'], ['e', 'm']]);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1078]

PUB FN ARRAY_CHUNKS<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&SELF) -> ARRAYCHUNKS
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.ArrayChunks.html]<'_, T, N>

🔬This is a nightly-only experimental API. (array_chunks)

Returns an iterator over N elements of the slice at a time, starting at the beginning of the slice.

The chunks are array references and do not overlap. If N does not divide the length of the slice, then the last up to N-1 elements
will be omitted and can be retrieved from the remainder function of the iterator.

This method is the const generic equivalent of chunks_exact
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks_exact].

PANICS

Panics if N is 0. This check will most probably get changed to a compile time error before this method gets stabilized.

EXAMPLES

#![feature(array_chunks)]
let slice = ['l', 'o', 'r', 'e', 'm'];
let mut iter = slice.array_chunks();
assert_eq!(iter.next().unwrap(), &['l', 'o']);
assert_eq!(iter.next().unwrap(), &['r', 'e']);
assert!(iter.next().is_none());
assert_eq!(iter.remainder(), &['m']);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1115]

PUB UNSAFE FN AS_CHUNKS_UNCHECKED_MUT<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(
    &MUT SELF
) -> &MUT [[T; N] [https://doc.rust-lang.org/1.67.0/std/primitive.array.html]]

🔬This is a nightly-only experimental API. (slice_as_chunks)

Splits the slice into a slice of N-element arrays, assuming that there’s no remainder.

SAFETY

This may only be called when

 * The slice splits exactly into N-element chunks (aka self.len() % N == 0).
 * N != 0.

EXAMPLES

#![feature(slice_as_chunks)]
let slice: &mut [char] = &mut ['l', 'o', 'r', 'e', 'm', '!'];
let chunks: &mut [[char; 1]] =
    // SAFETY: 1-element chunks never have remainder
    unsafe { slice.as_chunks_unchecked_mut() };
chunks[0] = ['L'];
assert_eq!(chunks, &[['L'], ['o'], ['r'], ['e'], ['m'], ['!']]);
let chunks: &mut [[char; 3]] =
    // SAFETY: The slice length (6) is a multiple of 3
    unsafe { slice.as_chunks_unchecked_mut() };
chunks[1] = ['a', 'x', '?'];
assert_eq!(slice, &['L', 'o', 'r', 'a', 'x', '?']);

// These would be unsound:
// let chunks: &[[_; 5]] = slice.as_chunks_unchecked_mut() // The slice length is not a multiple of 5
// let chunks: &[[_; 0]] = slice.as_chunks_unchecked_mut() // Zero-length chunks are never allowed

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1157]

PUB FN AS_CHUNKS_MUT<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&MUT SELF) -> (&MUT [[T; N]
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html]], &MUT [T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])

🔬This is a nightly-only experimental API. (slice_as_chunks)

Splits the slice into a slice of N-element arrays, starting at the beginning of the slice, and a remainder slice with length
strictly less than N.

PANICS

Panics if N is 0. This check will most probably get changed to a compile time error before this method gets stabilized.

EXAMPLES

#![feature(slice_as_chunks)]
let v = &mut [0, 0, 0, 0, 0];
let mut count = 1;

let (chunks, remainder) = v.as_chunks_mut();
remainder[0] = 9;
for chunk in chunks {
    *chunk = [count; 2];
    count += 1;
}
assert_eq!(v, &[1, 1, 2, 2, 9]);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1194]

PUB FN AS_RCHUNKS_MUT<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&MUT SELF) -> (&MUT [T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &MUT [[T; N]
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html]])

🔬This is a nightly-only experimental API. (slice_as_chunks)

Splits the slice into a slice of N-element arrays, starting at the end of the slice, and a remainder slice with length strictly
less than N.

PANICS

Panics if N is 0. This check will most probably get changed to a compile time error before this method gets stabilized.

EXAMPLES

#![feature(slice_as_chunks)]
let v = &mut [0, 0, 0, 0, 0];
let mut count = 1;

let (remainder, chunks) = v.as_rchunks_mut();
remainder[0] = 9;
for chunk in chunks {
    *chunk = [count; 2];
    count += 1;
}
assert_eq!(v, &[9, 1, 1, 2, 2]);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1235]

PUB FN ARRAY_CHUNKS_MUT<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&MUT SELF) -> ARRAYCHUNKSMUT
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.ArrayChunksMut.html]<'_, T, N>

🔬This is a nightly-only experimental API. (array_chunks)

Returns an iterator over N elements of the slice at a time, starting at the beginning of the slice.

The chunks are mutable array references and do not overlap. If N does not divide the length of the slice, then the last up to N-1
elements will be omitted and can be retrieved from the into_remainder function of the iterator.

This method is the const generic equivalent of chunks_exact_mut
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks_exact_mut].

PANICS

Panics if N is 0. This check will most probably get changed to a compile time error before this method gets stabilized.

EXAMPLES

#![feature(array_chunks)]
let v = &mut [0, 0, 0, 0, 0];
let mut count = 1;

for chunk in v.array_chunks_mut() {
    *chunk = [count; 2];
    count += 1;
}
assert_eq!(v, &[1, 1, 2, 2, 0]);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1267]

PUB FN ARRAY_WINDOWS<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&SELF) -> ARRAYWINDOWS
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.ArrayWindows.html]<'_, T, N>

🔬This is a nightly-only experimental API. (array_windows)

Returns an iterator over overlapping windows of N elements of a slice, starting at the beginning of the slice.

This is the const generic equivalent of windows [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.windows].

If N is greater than the size of the slice, it will return no windows.

PANICS

Panics if N is 0. This check will most probably get changed to a compile time error before this method gets stabilized.

EXAMPLES

#![feature(array_windows)]
let slice = [0, 1, 2, 3];
let mut iter = slice.array_windows();
assert_eq!(iter.next().unwrap(), &[0, 1]);
assert_eq!(iter.next().unwrap(), &[1, 2]);
assert_eq!(iter.next().unwrap(), &[2, 3]);
assert!(iter.next().is_none());

1.31.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1301]

PUB FN RCHUNKS(&SELF, CHUNK_SIZE: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> RCHUNKS
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.RChunks.html]<'_, T>

Returns an iterator over chunk_size elements of the slice at a time, starting at the end of the slice.

The chunks are slices and do not overlap. If chunk_size does not divide the length of the slice, then the last chunk will not have
length chunk_size.

See rchunks_exact [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.rchunks_exact] for a variant of this iterator
that returns chunks of always exactly chunk_size elements, and chunks
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks] for the same iterator but starting at the beginning of
the slice.

PANICS

Panics if chunk_size is 0.

EXAMPLES

let slice = ['l', 'o', 'r', 'e', 'm'];
let mut iter = slice.rchunks(2);
assert_eq!(iter.next().unwrap(), &['e', 'm']);
assert_eq!(iter.next().unwrap(), &['o', 'r']);
assert_eq!(iter.next().unwrap(), &['l']);
assert!(iter.next().is_none());

1.31.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1339]

PUB FN RCHUNKS_MUT(&MUT SELF, CHUNK_SIZE: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> RCHUNKSMUT
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.RChunksMut.html]<'_, T>

Returns an iterator over chunk_size elements of the slice at a time, starting at the end of the slice.

The chunks are mutable slices, and do not overlap. If chunk_size does not divide the length of the slice, then the last chunk will
not have length chunk_size.

See rchunks_exact_mut [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.rchunks_exact_mut] for a variant of this
iterator that returns chunks of always exactly chunk_size elements, and chunks_mut
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks_mut] for the same iterator but starting at the beginning
of the slice.

PANICS

Panics if chunk_size is 0.

EXAMPLES

let v = &mut [0, 0, 0, 0, 0];
let mut count = 1;

for chunk in v.rchunks_mut(2) {
    for elem in chunk.iter_mut() {
        *elem += count;
    }
    count += 1;
}
assert_eq!(v, &[3, 2, 2, 1, 1]);

1.31.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1378]

PUB FN RCHUNKS_EXACT(&SELF, CHUNK_SIZE: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> RCHUNKSEXACT
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.RChunksExact.html]<'_, T>

Returns an iterator over chunk_size elements of the slice at a time, starting at the end of the slice.

The chunks are slices and do not overlap. If chunk_size does not divide the length of the slice, then the last up to chunk_size-1
elements will be omitted and can be retrieved from the remainder function of the iterator.

Due to each chunk having exactly chunk_size elements, the compiler can often optimize the resulting code better than in the case
of rchunks [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.rchunks].

See rchunks [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.rchunks] for a variant of this iterator that also
returns the remainder as a smaller chunk, and chunks_exact
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks_exact] for the same iterator but starting at the
beginning of the slice.

PANICS

Panics if chunk_size is 0.

EXAMPLES

let slice = ['l', 'o', 'r', 'e', 'm'];
let mut iter = slice.rchunks_exact(2);
assert_eq!(iter.next().unwrap(), &['e', 'm']);
assert_eq!(iter.next().unwrap(), &['o', 'r']);
assert!(iter.next().is_none());
assert_eq!(iter.remainder(), &['l']);

1.31.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1421]

PUB FN RCHUNKS_EXACT_MUT(&MUT SELF, CHUNK_SIZE: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) ->
RCHUNKSEXACTMUT [https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.RChunksExactMut.html]<'_, T>

Returns an iterator over chunk_size elements of the slice at a time, starting at the end of the slice.

The chunks are mutable slices, and do not overlap. If chunk_size does not divide the length of the slice, then the last up to
chunk_size-1 elements will be omitted and can be retrieved from the into_remainder function of the iterator.

Due to each chunk having exactly chunk_size elements, the compiler can often optimize the resulting code better than in the case
of chunks_mut [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks_mut].

See rchunks_mut [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.rchunks_mut] for a variant of this iterator that
also returns the remainder as a smaller chunk, and chunks_exact_mut
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks_exact_mut] for the same iterator but starting at the
beginning of the slice.

PANICS

Panics if chunk_size is 0.

EXAMPLES

let v = &mut [0, 0, 0, 0, 0];
let mut count = 1;

for chunk in v.rchunks_exact_mut(2) {
    for elem in chunk.iter_mut() {
        *elem += count;
    }
    count += 1;
}
assert_eq!(v, &[0, 2, 2, 1, 1]);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1464-1466]

PUB FN GROUP_BY<F>(&SELF, PRED: F) -> GROUPBY [https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.GroupBy.html]<'_, T,
F>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T, &
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

🔬This is a nightly-only experimental API. (slice_group_by)

Returns an iterator over the slice producing non-overlapping runs of elements using the predicate to separate them.

The predicate is called on two elements following themselves, it means the predicate is called on slice[0] and slice[1] then on
slice[1] and slice[2] and so on.

EXAMPLES

#![feature(slice_group_by)]

let slice = &[1, 1, 1, 3, 3, 2, 2, 2];

let mut iter = slice.group_by(|a, b| a == b);

assert_eq!(iter.next(), Some(&[1, 1, 1][..]));
assert_eq!(iter.next(), Some(&[3, 3][..]));
assert_eq!(iter.next(), Some(&[2, 2, 2][..]));
assert_eq!(iter.next(), None);

This method can be used to extract the sorted subslices:

#![feature(slice_group_by)]

let slice = &[1, 1, 2, 3, 2, 3, 2, 3, 4];

let mut iter = slice.group_by(|a, b| a <= b);

assert_eq!(iter.next(), Some(&[1, 1, 2, 3][..]));
assert_eq!(iter.next(), Some(&[2, 3][..]));
assert_eq!(iter.next(), Some(&[2, 3, 4][..]));
assert_eq!(iter.next(), None);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1509-1511]

PUB FN GROUP_BY_MUT<F>(&MUT SELF, PRED: F) -> GROUPBYMUT
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.GroupByMut.html]<'_, T, F>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T, &
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

🔬This is a nightly-only experimental API. (slice_group_by)

Returns an iterator over the slice producing non-overlapping mutable runs of elements using the predicate to separate them.

The predicate is called on two elements following themselves, it means the predicate is called on slice[0] and slice[1] then on
slice[1] and slice[2] and so on.

EXAMPLES

#![feature(slice_group_by)]

let slice = &mut [1, 1, 1, 3, 3, 2, 2, 2];

let mut iter = slice.group_by_mut(|a, b| a == b);

assert_eq!(iter.next(), Some(&mut [1, 1, 1][..]));
assert_eq!(iter.next(), Some(&mut [3, 3][..]));
assert_eq!(iter.next(), Some(&mut [2, 2, 2][..]));
assert_eq!(iter.next(), None);

This method can be used to extract the sorted subslices:

#![feature(slice_group_by)]

let slice = &mut [1, 1, 2, 3, 2, 3, 2, 3, 4];

let mut iter = slice.group_by_mut(|a, b| a <= b);

assert_eq!(iter.next(), Some(&mut [1, 1, 2, 3][..]));
assert_eq!(iter.next(), Some(&mut [2, 3][..]));
assert_eq!(iter.next(), Some(&mut [2, 3, 4][..]));
assert_eq!(iter.next(), None);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1554]

PUB FN SPLIT_AT(&SELF, MID: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> (&[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])

Divides one slice into two at an index.

The first will contain all indices from [0, mid) (excluding the index mid itself) and the second will contain all indices from
[mid, len) (excluding the index len itself).

PANICS

Panics if mid > len.

EXAMPLES

let v = [1, 2, 3, 4, 5, 6];

{
   let (left, right) = v.split_at(0);
   assert_eq!(left, []);
   assert_eq!(right, [1, 2, 3, 4, 5, 6]);
}

{
    let (left, right) = v.split_at(2);
    assert_eq!(left, [1, 2]);
    assert_eq!(right, [3, 4, 5, 6]);
}

{
    let (left, right) = v.split_at(6);
    assert_eq!(left, [1, 2, 3, 4, 5, 6]);
    assert_eq!(right, []);
}

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1587]

PUB FN SPLIT_AT_MUT(&MUT SELF, MID: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> (&MUT [T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])

Divides one mutable slice into two at an index.

The first will contain all indices from [0, mid) (excluding the index mid itself) and the second will contain all indices from
[mid, len) (excluding the index len itself).

PANICS

Panics if mid > len.

EXAMPLES

let mut v = [1, 0, 3, 0, 5, 6];
let (left, right) = v.split_at_mut(2);
assert_eq!(left, [1, 0]);
assert_eq!(right, [3, 0, 5, 6]);
left[1] = 2;
right[1] = 4;
assert_eq!(v, [1, 2, 3, 4, 5, 6]);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1640]

PUB UNSAFE FN SPLIT_AT_UNCHECKED(&SELF, MID: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> (&[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])

🔬This is a nightly-only experimental API. (slice_split_at_unchecked)

Divides one slice into two at an index, without doing bounds checking.

The first will contain all indices from [0, mid) (excluding the index mid itself) and the second will contain all indices from
[mid, len) (excluding the index len itself).

For a safe alternative see split_at [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.split_at].

SAFETY

Calling this method with an out-of-bounds index is undefined behavior
[https://doc.rust-lang.org/reference/behavior-considered-undefined.html] even if the resulting reference is not used. The caller
has to ensure that 0 <= mid <= self.len().

EXAMPLES

#![feature(slice_split_at_unchecked)]

let v = [1, 2, 3, 4, 5, 6];

unsafe {
   let (left, right) = v.split_at_unchecked(0);
   assert_eq!(left, []);
   assert_eq!(right, [1, 2, 3, 4, 5, 6]);
}

unsafe {
    let (left, right) = v.split_at_unchecked(2);
    assert_eq!(left, [1, 2]);
    assert_eq!(right, [3, 4, 5, 6]);
}

unsafe {
    let (left, right) = v.split_at_unchecked(6);
    assert_eq!(left, [1, 2, 3, 4, 5, 6]);
    assert_eq!(right, []);
}

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1689]

PUB UNSAFE FN SPLIT_AT_MUT_UNCHECKED(
    &MUT SELF,
    MID: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]
) -> (&MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &MUT [T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])

🔬This is a nightly-only experimental API. (slice_split_at_unchecked)

Divides one mutable slice into two at an index, without doing bounds checking.

The first will contain all indices from [0, mid) (excluding the index mid itself) and the second will contain all indices from
[mid, len) (excluding the index len itself).

For a safe alternative see split_at_mut [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.split_at_mut].

SAFETY

Calling this method with an out-of-bounds index is undefined behavior
[https://doc.rust-lang.org/reference/behavior-considered-undefined.html] even if the resulting reference is not used. The caller
has to ensure that 0 <= mid <= self.len().

EXAMPLES

#![feature(slice_split_at_unchecked)]

let mut v = [1, 0, 3, 0, 5, 6];
// scoped to restrict the lifetime of the borrows
unsafe {
    let (left, right) = v.split_at_mut_unchecked(2);
    assert_eq!(left, [1, 0]);
    assert_eq!(right, [3, 0, 5, 6]);
    left[1] = 2;
    right[1] = 4;
}
assert_eq!(v, [1, 2, 3, 4, 5, 6]);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1745]

PUB FN SPLIT_ARRAY_REF<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&SELF) -> (&[T; N]
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html], &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])

🔬This is a nightly-only experimental API. (split_array)

Divides one slice into an array and a remainder slice at an index.

The array will contain all indices from [0, N) (excluding the index N itself) and the slice will contain all indices from [N, len)
(excluding the index len itself).

PANICS

Panics if N > len.

EXAMPLES

#![feature(split_array)]

let v = &[1, 2, 3, 4, 5, 6][..];

{
   let (left, right) = v.split_array_ref::<0>();
   assert_eq!(left, &[]);
   assert_eq!(right, [1, 2, 3, 4, 5, 6]);
}

{
    let (left, right) = v.split_array_ref::<2>();
    assert_eq!(left, &[1, 2]);
    assert_eq!(right, [3, 4, 5, 6]);
}

{
    let (left, right) = v.split_array_ref::<6>();
    assert_eq!(left, &[1, 2, 3, 4, 5, 6]);
    assert_eq!(right, []);
}

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1778]

PUB FN SPLIT_ARRAY_MUT<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&MUT SELF) -> (&MUT [T; N]
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html], &MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])

🔬This is a nightly-only experimental API. (split_array)

Divides one mutable slice into an array and a remainder slice at an index.

The array will contain all indices from [0, N) (excluding the index N itself) and the slice will contain all indices from [N, len)
(excluding the index len itself).

PANICS

Panics if N > len.

EXAMPLES

#![feature(split_array)]

let mut v = &mut [1, 0, 3, 0, 5, 6][..];
let (left, right) = v.split_array_mut::<2>();
assert_eq!(left, &mut [1, 0]);
assert_eq!(right, [3, 0, 5, 6]);
left[1] = 2;
right[1] = 4;
assert_eq!(v, [1, 2, 3, 4, 5, 6]);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1823]

PUB FN RSPLIT_ARRAY_REF<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&SELF) -> (&[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &[T; N] [https://doc.rust-lang.org/1.67.0/std/primitive.array.html])

🔬This is a nightly-only experimental API. (split_array)

Divides one slice into an array and a remainder slice at an index from the end.

The slice will contain all indices from [0, len - N) (excluding the index len - N itself) and the array will contain all indices
from [len - N, len) (excluding the index len itself).

PANICS

Panics if N > len.

EXAMPLES

#![feature(split_array)]

let v = &[1, 2, 3, 4, 5, 6][..];

{
   let (left, right) = v.rsplit_array_ref::<0>();
   assert_eq!(left, [1, 2, 3, 4, 5, 6]);
   assert_eq!(right, &[]);
}

{
    let (left, right) = v.rsplit_array_ref::<2>();
    assert_eq!(left, [1, 2, 3, 4]);
    assert_eq!(right, &[5, 6]);
}

{
    let (left, right) = v.rsplit_array_ref::<6>();
    assert_eq!(left, []);
    assert_eq!(right, &[1, 2, 3, 4, 5, 6]);
}

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1857]

PUB FN RSPLIT_ARRAY_MUT<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&MUT SELF) -> (&MUT [T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &MUT [T; N]
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html])

🔬This is a nightly-only experimental API. (split_array)

Divides one mutable slice into an array and a remainder slice at an index from the end.

The slice will contain all indices from [0, len - N) (excluding the index N itself) and the array will contain all indices from
[len - N, len) (excluding the index len itself).

PANICS

Panics if N > len.

EXAMPLES

#![feature(split_array)]

let mut v = &mut [1, 0, 3, 0, 5, 6][..];
let (left, right) = v.rsplit_array_mut::<4>();
assert_eq!(left, [1, 0]);
assert_eq!(right, &mut [3, 0, 5, 6]);
left[1] = 2;
right[1] = 4;
assert_eq!(v, [1, 2, 3, 4, 5, 6]);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1906-1908]

PUB FN SPLIT<F>(&SELF, PRED: F) -> SPLIT [https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.Split.html]<'_, T, F>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

Returns an iterator over subslices separated by elements that match pred. The matched element is not contained in the subslices.

EXAMPLES

let slice = [10, 40, 33, 20];
let mut iter = slice.split(|num| num % 3 == 0);

assert_eq!(iter.next().unwrap(), &[10, 40]);
assert_eq!(iter.next().unwrap(), &[20]);
assert!(iter.next().is_none());

If the first element is matched, an empty slice will be the first item returned by the iterator. Similarly, if the last element in
the slice is matched, an empty slice will be the last item returned by the iterator:

let slice = [10, 40, 33];
let mut iter = slice.split(|num| num % 3 == 0);

assert_eq!(iter.next().unwrap(), &[10, 40]);
assert_eq!(iter.next().unwrap(), &[]);
assert!(iter.next().is_none());

If two matched elements are directly adjacent, an empty slice will be present between them:

let slice = [10, 6, 33, 20];
let mut iter = slice.split(|num| num % 3 == 0);

assert_eq!(iter.next().unwrap(), &[10]);
assert_eq!(iter.next().unwrap(), &[]);
assert_eq!(iter.next().unwrap(), &[20]);
assert!(iter.next().is_none());

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1928-1930]

PUB FN SPLIT_MUT<F>(&MUT SELF, PRED: F) -> SPLITMUT [https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.SplitMut.html]<'_, T,
F>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

Returns an iterator over mutable subslices separated by elements that match pred. The matched element is not contained in the
subslices.

EXAMPLES

let mut v = [10, 40, 30, 20, 60, 50];

for group in v.split_mut(|num| *num % 3 == 0) {
    group[0] = 1;
}
assert_eq!(v, [1, 40, 30, 1, 60, 1]);

1.51.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1964-1966]

PUB FN SPLIT_INCLUSIVE<F>(&SELF, PRED: F) -> SPLITINCLUSIVE
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.SplitInclusive.html]<'_, T, F>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

Returns an iterator over subslices separated by elements that match pred. The matched element is contained in the end of the
previous subslice as a terminator.

EXAMPLES

let slice = [10, 40, 33, 20];
let mut iter = slice.split_inclusive(|num| num % 3 == 0);

assert_eq!(iter.next().unwrap(), &[10, 40, 33]);
assert_eq!(iter.next().unwrap(), &[20]);
assert!(iter.next().is_none());

If the last element of the slice is matched, that element will be considered the terminator of the preceding slice. That slice
will be the last item returned by the iterator.

let slice = [3, 10, 40, 33];
let mut iter = slice.split_inclusive(|num| num % 3 == 0);

assert_eq!(iter.next().unwrap(), &[3]);
assert_eq!(iter.next().unwrap(), &[10, 40, 33]);
assert!(iter.next().is_none());

1.51.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1988-1990]

PUB FN SPLIT_INCLUSIVE_MUT<F>(&MUT SELF, PRED: F) -> SPLITINCLUSIVEMUT
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.SplitInclusiveMut.html]<'_, T, F>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

Returns an iterator over mutable subslices separated by elements that match pred. The matched element is contained in the previous
subslice as a terminator.

EXAMPLES

let mut v = [10, 40, 30, 20, 60, 50];

for group in v.split_inclusive_mut(|num| *num % 3 == 0) {
    let terminator_idx = group.len()-1;
    group[terminator_idx] = 1;
}
assert_eq!(v, [10, 40, 1, 20, 1, 1]);

1.27.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2024-2026]

PUB FN RSPLIT<F>(&SELF, PRED: F) -> RSPLIT [https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.RSplit.html]<'_, T, F>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

Returns an iterator over subslices separated by elements that match pred, starting at the end of the slice and working backwards.
The matched element is not contained in the subslices.

EXAMPLES

let slice = [11, 22, 33, 0, 44, 55];
let mut iter = slice.rsplit(|num| *num == 0);

assert_eq!(iter.next().unwrap(), &[44, 55]);
assert_eq!(iter.next().unwrap(), &[11, 22, 33]);
assert_eq!(iter.next(), None);

As with split(), if the first or last element is matched, an empty slice will be the first (or last) item returned by the
iterator.

let v = &[0, 1, 1, 2, 3, 5, 8];
let mut it = v.rsplit(|n| *n % 2 == 0);
assert_eq!(it.next().unwrap(), &[]);
assert_eq!(it.next().unwrap(), &[3, 5]);
assert_eq!(it.next().unwrap(), &[1, 1]);
assert_eq!(it.next().unwrap(), &[]);
assert_eq!(it.next(), None);

1.27.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2050-2052]

PUB FN RSPLIT_MUT<F>(&MUT SELF, PRED: F) -> RSPLITMUT [https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.RSplitMut.html]<'_,
T, F>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

Returns an iterator over mutable subslices separated by elements that match pred, starting at the end of the slice and working
backwards. The matched element is not contained in the subslices.

EXAMPLES

let mut v = [100, 400, 300, 200, 600, 500];

let mut count = 0;
for group in v.rsplit_mut(|num| *num % 3 == 0) {
    count += 1;
    group[0] = count;
}
assert_eq!(v, [3, 400, 300, 2, 600, 1]);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2078-2080]

PUB FN SPLITN<F>(&SELF, N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html], PRED: F) -> SPLITN
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.SplitN.html]<'_, T, F>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

Returns an iterator over subslices separated by elements that match pred, limited to returning at most n items. The matched
element is not contained in the subslices.

The last element returned, if any, will contain the remainder of the slice.

EXAMPLES

Print the slice split once by numbers divisible by 3 (i.e., [10, 40], [20, 60, 50]):

let v = [10, 40, 30, 20, 60, 50];

for group in v.splitn(2, |num| *num % 3 == 0) {
    println!("{group:?}");
}

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2104-2106]

PUB FN SPLITN_MUT<F>(&MUT SELF, N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html], PRED: F) -> SPLITNMUT
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.SplitNMut.html]<'_, T, F>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

Returns an iterator over mutable subslices separated by elements that match pred, limited to returning at most n items. The
matched element is not contained in the subslices.

The last element returned, if any, will contain the remainder of the slice.

EXAMPLES

let mut v = [10, 40, 30, 20, 60, 50];

for group in v.splitn_mut(2, |num| *num % 3 == 0) {
    group[0] = 1;
}
assert_eq!(v, [1, 40, 30, 1, 60, 50]);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2133-2135]

PUB FN RSPLITN<F>(&SELF, N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html], PRED: F) -> RSPLITN
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.RSplitN.html]<'_, T, F>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

Returns an iterator over subslices separated by elements that match pred limited to returning at most n items. This starts at the
end of the slice and works backwards. The matched element is not contained in the subslices.

The last element returned, if any, will contain the remainder of the slice.

EXAMPLES

Print the slice split once, starting from the end, by numbers divisible by 3 (i.e., [50], [10, 40, 30, 20]):

let v = [10, 40, 30, 20, 60, 50];

for group in v.rsplitn(2, |num| *num % 3 == 0) {
    println!("{group:?}");
}

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2160-2162]

PUB FN RSPLITN_MUT<F>(&MUT SELF, N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html], PRED: F) -> RSPLITNMUT
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.RSplitNMut.html]<'_, T, F>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

Returns an iterator over subslices separated by elements that match pred limited to returning at most n items. This starts at the
end of the slice and works backwards. The matched element is not contained in the subslices.

The last element returned, if any, will contain the remainder of the slice.

EXAMPLES

let mut s = [10, 40, 30, 20, 60, 50];

for group in s.rsplitn_mut(2, |num| *num % 3 == 0) {
    group[0] = 1;
}
assert_eq!(s, [1, 40, 30, 20, 60, 1]);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2195-2197]

PUB FN CONTAINS(&SELF, X: & [https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]WHERE
    T: PARTIALEQ [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialEq.html]<T>,

Returns true if the slice contains an element with the given value.

This operation is O(n).

Note that if you have a sorted slice, binary_search
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search] may be faster.

EXAMPLES

let v = [10, 40, 30];
assert!(v.contains(&30));
assert!(!v.contains(&50));

If you do not have a &T, but some other value that you can compare with one (for example, String implements PartialEq<str>), you
can use iter().any:

let v = [String::from("hello"), String::from("world")]; // slice of `String`
assert!(v.iter().any(|e| e == "hello")); // search with `&str`
assert!(!v.iter().any(|e| e == "hi"));

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2224-2226]

PUB FN STARTS_WITH(&SELF, NEEDLE: &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]WHERE
    T: PARTIALEQ [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialEq.html]<T>,

Returns true if needle is a prefix of the slice.

EXAMPLES

let v = [10, 40, 30];
assert!(v.starts_with(&[10]));
assert!(v.starts_with(&[10, 40]));
assert!(!v.starts_with(&[50]));
assert!(!v.starts_with(&[10, 50]));

Always returns true if needle is an empty slice:

let v = &[10, 40, 30];
assert!(v.starts_with(&[]));
let v: &[u8] = &[];
assert!(v.starts_with(&[]));

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2254-2256]

PUB FN ENDS_WITH(&SELF, NEEDLE: &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]WHERE
    T: PARTIALEQ [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialEq.html]<T>,

Returns true if needle is a suffix of the slice.

EXAMPLES

let v = [10, 40, 30];
assert!(v.ends_with(&[30]));
assert!(v.ends_with(&[40, 30]));
assert!(!v.ends_with(&[50]));
assert!(!v.ends_with(&[50, 30]));

Always returns true if needle is an empty slice:

let v = &[10, 40, 30];
assert!(v.ends_with(&[]));
let v: &[u8] = &[];
assert!(v.ends_with(&[]));

1.51.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2284-2286]

PUB FN STRIP_PREFIX<P>(&SELF, PREFIX: & [https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]P) -> OPTION
[https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>WHERE
    P: SLICEPATTERN [https://doc.rust-lang.org/1.67.0/core/slice/trait.SlicePattern.html]<ITEM = T> + ?SIZED
[https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],
    T: PARTIALEQ [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialEq.html]<T>,

Returns a subslice with the prefix removed.

If the slice starts with prefix, returns the subslice after the prefix, wrapped in Some. If prefix is empty, simply returns the
original slice.

If the slice does not start with prefix, returns None.

EXAMPLES

let v = &[10, 40, 30];
assert_eq!(v.strip_prefix(&[10]), Some(&[40, 30][..]));
assert_eq!(v.strip_prefix(&[10, 40]), Some(&[30][..]));
assert_eq!(v.strip_prefix(&[50]), None);
assert_eq!(v.strip_prefix(&[10, 50]), None);

let prefix : &str = "he";
assert_eq!(b"hello".strip_prefix(prefix.as_bytes()),
           Some(b"llo".as_ref()));

1.51.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2318-2320]

PUB FN STRIP_SUFFIX<P>(&SELF, SUFFIX: & [https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]P) -> OPTION
[https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>WHERE
    P: SLICEPATTERN [https://doc.rust-lang.org/1.67.0/core/slice/trait.SlicePattern.html]<ITEM = T> + ?SIZED
[https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],
    T: PARTIALEQ [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialEq.html]<T>,

Returns a subslice with the suffix removed.

If the slice ends with suffix, returns the subslice before the suffix, wrapped in Some. If suffix is empty, simply returns the
original slice.

If the slice does not end with suffix, returns None.

EXAMPLES

let v = &[10, 40, 30];
assert_eq!(v.strip_suffix(&[30]), Some(&[10, 40][..]));
assert_eq!(v.strip_suffix(&[40, 30]), Some(&[10][..]));
assert_eq!(v.strip_suffix(&[50]), None);
assert_eq!(v.strip_suffix(&[50, 30]), None);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2402-2404]

PUB FN BINARY_SEARCH(&SELF, X: & [https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> RESULT
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html],
USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>WHERE
    T: ORD [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html],

Binary searches this slice for a given element. This behaves similarly to contains
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.contains] if this slice is sorted.

If the value is found then Result::Ok [https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html#variant.Ok] is returned,
containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. The
index is chosen deterministically, but is subject to change in future versions of Rust. If the value is not found then Result::Err
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html#variant.Err] is returned, containing the index where a matching
element could be inserted while maintaining sorted order.

See also binary_search_by [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search_by],
binary_search_by_key [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search_by_key], and partition_point
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.partition_point].

EXAMPLES

Looks up a series of four elements. The first is found, with a uniquely determined position; the second and third are not found;
the fourth could match any position in [1, 4].

let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];

assert_eq!(s.binary_search(&13),  Ok(9));
assert_eq!(s.binary_search(&4),   Err(7));
assert_eq!(s.binary_search(&100), Err(13));
let r = s.binary_search(&1);
assert!(match r { Ok(1..=4) => true, _ => false, });

If you want to find that whole range of matching items, rather than an arbitrary matching one, that can be done using
partition_point [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.partition_point]:

let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];

let low = s.partition_point(|x| x < &1);
assert_eq!(low, 1);
let high = s.partition_point(|x| x <= &1);
assert_eq!(high, 5);
let r = s.binary_search(&1);
assert!((low..high).contains(&r.unwrap()));

assert!(s[..low].iter().all(|&x| x < 1));
assert!(s[low..high].iter().all(|&x| x == 1));
assert!(s[high..].iter().all(|&x| x > 1));

// For something not found, the "range" of equal items is empty
assert_eq!(s.partition_point(|x| x < &11), 9);
assert_eq!(s.partition_point(|x| x <= &11), 9);
assert_eq!(s.binary_search(&11), Err(9));

If you want to insert an item to a sorted vector, while maintaining sort order, consider using partition_point
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.partition_point]:

let mut s = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];
let num = 42;
let idx = s.partition_point(|&x| x < num);
// The above is equivalent to `let idx = s.binary_search(&num).unwrap_or_else(|x| x);`
s.insert(idx, num);
assert_eq!(s, [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2453-2455]

PUB FN BINARY_SEARCH_BY<'A, F>(&'A SELF, F: F) -> RESULT [https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<USIZE
[https://doc.rust-lang.org/1.67.0/std/primitive.usize.html], USIZE
[https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&'A
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> ORDERING
[https://doc.rust-lang.org/1.67.0/core/cmp/enum.Ordering.html],

Binary searches this slice with a comparator function. This behaves similarly to contains
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.contains] if this slice is sorted.

The comparator function should implement an order consistent with the sort order of the underlying slice, returning an order code
that indicates whether its argument is Less, Equal or Greater the desired target.

If the value is found then Result::Ok [https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html#variant.Ok] is returned,
containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. The
index is chosen deterministically, but is subject to change in future versions of Rust. If the value is not found then Result::Err
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html#variant.Err] is returned, containing the index where a matching
element could be inserted while maintaining sorted order.

See also binary_search [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search], binary_search_by_key
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search_by_key], and partition_point
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.partition_point].

EXAMPLES

Looks up a series of four elements. The first is found, with a uniquely determined position; the second and third are not found;
the fourth could match any position in [1, 4].

let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];

let seek = 13;
assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));
let seek = 4;
assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));
let seek = 100;
assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));
let seek = 1;
let r = s.binary_search_by(|probe| probe.cmp(&seek));
assert!(match r { Ok(1..=4) => true, _ => false, });

1.10.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2542-2545]

PUB FN BINARY_SEARCH_BY_KEY<'A, B, F>(
    &'A SELF,
    B: & [https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]B,
    F: F
) -> RESULT [https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<USIZE
[https://doc.rust-lang.org/1.67.0/std/primitive.usize.html], USIZE
[https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&'A
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> B,
    B: ORD [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html],

Binary searches this slice with a key extraction function. This behaves similarly to contains
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.contains] if this slice is sorted.

Assumes that the slice is sorted by the key, for instance with sort_by_key
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.sort_by_key] using the same key extraction function.

If the value is found then Result::Ok [https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html#variant.Ok] is returned,
containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. The
index is chosen deterministically, but is subject to change in future versions of Rust. If the value is not found then Result::Err
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html#variant.Err] is returned, containing the index where a matching
element could be inserted while maintaining sorted order.

See also binary_search [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search], binary_search_by
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search_by], and partition_point
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.partition_point].

EXAMPLES

Looks up a series of four elements in a slice of pairs sorted by their second elements. The first is found, with a uniquely
determined position; the second and third are not found; the fourth could match any position in [1, 4].

let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),
         (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),
         (1, 21), (2, 34), (4, 55)];

assert_eq!(s.binary_search_by_key(&13, |&(a, b)| b),  Ok(9));
assert_eq!(s.binary_search_by_key(&4, |&(a, b)| b),   Err(7));
assert_eq!(s.binary_search_by_key(&100, |&(a, b)| b), Err(13));
let r = s.binary_search_by_key(&1, |&(a, b)| b);
assert!(match r { Ok(1..=4) => true, _ => false, });

1.20.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2578-2580]

PUB FN SORT_UNSTABLE(&MUT SELF)WHERE
    T: ORD [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html],

Sorts the slice, but might not preserve the order of equal elements.

This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and O(n * log(n)) worst-case.

CURRENT IMPLEMENTATION

The current algorithm is based on pattern-defeating quicksort [https://github.com/orlp/pdqsort] by Orson Peters, which combines
the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with
certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic
behavior.

It is typically faster than stable sorting, except in a few special cases, e.g., when the slice consists of several concatenated
sorted sequences.

EXAMPLES

let mut v = [-5, 4, 1, -3, 2];

v.sort_unstable();
assert!(v == [-5, -3, 1, 2, 4]);

1.20.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2633-2635]

PUB FN SORT_UNSTABLE_BY<F>(&MUT SELF, COMPARE: F)WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T, &
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> ORDERING
[https://doc.rust-lang.org/1.67.0/core/cmp/enum.Ordering.html],

Sorts the slice with a comparator function, but might not preserve the order of equal elements.

This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and O(n * log(n)) worst-case.

The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the
elements is unspecified. An order is a total order if it is (for all a, b and c):

 * total and antisymmetric: exactly one of a < b, a == b or a > b is true, and
 * transitive, a < b and b < c implies a < c. The same must hold for both == and >.

For example, while f64 [https://doc.rust-lang.org/1.67.0/std/primitive.f64.html] doesn’t implement Ord
[https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html] because NaN != NaN, we can use partial_cmp as our sort function when we
know the slice doesn’t contain a NaN.

let mut floats = [5f64, 4.0, 1.0, 3.0, 2.0];
floats.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());
assert_eq!(floats, [1.0, 2.0, 3.0, 4.0, 5.0]);

CURRENT IMPLEMENTATION

The current algorithm is based on pattern-defeating quicksort [https://github.com/orlp/pdqsort] by Orson Peters, which combines
the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with
certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic
behavior.

It is typically faster than stable sorting, except in a few special cases, e.g., when the slice consists of several concatenated
sorted sequences.

EXAMPLES

let mut v = [5, 4, 1, 3, 2];
v.sort_unstable_by(|a, b| a.cmp(b));
assert!(v == [1, 2, 3, 4, 5]);

// reverse sorting
v.sort_unstable_by(|a, b| b.cmp(a));
assert!(v == [5, 4, 3, 2, 1]);

1.20.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2671-2674]

PUB FN SORT_UNSTABLE_BY_KEY<K, F>(&MUT SELF, F: F)WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> K,
    K: ORD [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html],

Sorts the slice with a key extraction function, but might not preserve the order of equal elements.

This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not allocate), and O(m * n * log(n)) worst-case,
where the key function is O(m).

CURRENT IMPLEMENTATION

The current algorithm is based on pattern-defeating quicksort [https://github.com/orlp/pdqsort] by Orson Peters, which combines
the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with
certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic
behavior.

Due to its key calling strategy, sort_unstable_by_key is likely to be slower than sort_by_cached_key in cases where the key
function is expensive.

EXAMPLES

let mut v = [-5i32, 4, 1, -3, 2];

v.sort_unstable_by_key(|k| k.abs());
assert!(v == [1, 2, -3, 4, -5]);

1.49.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2718-2720]

PUB FN SELECT_NTH_UNSTABLE(
    &MUT SELF,
    INDEX: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]
) -> (&MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T, &MUT [T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])WHERE
    T: ORD [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html],

Reorder the slice such that the element at index is at its final sorted position.

This reordering has the additional property that any value at position i < index will be less than or equal to any value at a
position j > index. Additionally, this reordering is unstable (i.e. any number of equal elements may end up at position index),
in-place (i.e. does not allocate), and O(n) worst-case. This function is also/ known as “kth element” in other libraries. It
returns a triplet of the following from the reordered slice: the subslice prior to index, the element at index, and the subslice
after index; accordingly, the values in those two subslices will respectively all be less-than-or-equal-to and
greater-than-or-equal-to the value of the element at index.

CURRENT IMPLEMENTATION

The current algorithm is based on the quickselect portion of the same quicksort algorithm used for sort_unstable
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.sort_unstable].

PANICS

Panics when index >= len(), meaning it always panics on empty slices.

EXAMPLES

let mut v = [-5i32, 4, 1, -3, 2];

// Find the median
v.select_nth_unstable(2);

// We are only guaranteed the slice will be one of the following, based on the way we sort
// about the specified index.
assert!(v == [-3, -5, 1, 2, 4] ||
        v == [-5, -3, 1, 2, 4] ||
        v == [-3, -5, 1, 4, 2] ||
        v == [-5, -3, 1, 4, 2]);

1.49.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2766-2772]

PUB FN SELECT_NTH_UNSTABLE_BY<F>(
    &MUT SELF,
    INDEX: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html],
    COMPARE: F
) -> (&MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T, &MUT [T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T, &
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> ORDERING
[https://doc.rust-lang.org/1.67.0/core/cmp/enum.Ordering.html],

Reorder the slice with a comparator function such that the element at index is at its final sorted position.

This reordering has the additional property that any value at position i < index will be less than or equal to any value at a
position j > index using the comparator function. Additionally, this reordering is unstable (i.e. any number of equal elements may
end up at position index), in-place (i.e. does not allocate), and O(n) worst-case. This function is also known as “kth element” in
other libraries. It returns a triplet of the following from the slice reordered according to the provided comparator function: the
subslice prior to index, the element at index, and the subslice after index; accordingly, the values in those two subslices will
respectively all be less-than-or-equal-to and greater-than-or-equal-to the value of the element at index.

CURRENT IMPLEMENTATION

The current algorithm is based on the quickselect portion of the same quicksort algorithm used for sort_unstable
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.sort_unstable].

PANICS

Panics when index >= len(), meaning it always panics on empty slices.

EXAMPLES

let mut v = [-5i32, 4, 1, -3, 2];

// Find the median as if the slice were sorted in descending order.
v.select_nth_unstable_by(2, |a, b| b.cmp(a));

// We are only guaranteed the slice will be one of the following, based on the way we sort
// about the specified index.
assert!(v == [2, 4, 1, -5, -3] ||
        v == [2, 4, 1, -3, -5] ||
        v == [4, 2, 1, -5, -3] ||
        v == [4, 2, 1, -3, -5]);

1.49.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2818-2825]

PUB FN SELECT_NTH_UNSTABLE_BY_KEY<K, F>(
    &MUT SELF,
    INDEX: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html],
    F: F
) -> (&MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T, &MUT [T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> K,
    K: ORD [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html],

Reorder the slice with a key extraction function such that the element at index is at its final sorted position.

This reordering has the additional property that any value at position i < index will be less than or equal to any value at a
position j > index using the key extraction function. Additionally, this reordering is unstable (i.e. any number of equal elements
may end up at position index), in-place (i.e. does not allocate), and O(n) worst-case. This function is also known as “kth
element” in other libraries. It returns a triplet of the following from the slice reordered according to the provided key
extraction function: the subslice prior to index, the element at index, and the subslice after index; accordingly, the values in
those two subslices will respectively all be less-than-or-equal-to and greater-than-or-equal-to the value of the element at index.

CURRENT IMPLEMENTATION

The current algorithm is based on the quickselect portion of the same quicksort algorithm used for sort_unstable
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.sort_unstable].

PANICS

Panics when index >= len(), meaning it always panics on empty slices.

EXAMPLES

let mut v = [-5i32, 4, 1, -3, 2];

// Return the median as if the array were sorted according to absolute value.
v.select_nth_unstable_by_key(2, |a| a.abs());

// We are only guaranteed the slice will be one of the following, based on the way we sort
// about the specified index.
assert!(v == [1, 2, -3, 4, -5] ||
        v == [1, 2, -3, -5, 4] ||
        v == [2, 1, -3, 4, -5] ||
        v == [2, 1, -3, -5, 4]);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2852-2854]

PUB FN PARTITION_DEDUP(&MUT SELF) -> (&MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &MUT [T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])WHERE
    T: PARTIALEQ [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialEq.html]<T>,

🔬This is a nightly-only experimental API. (slice_partition_dedup)

Moves all consecutive repeated elements to the end of the slice according to the PartialEq
[https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialEq.html] trait implementation.

Returns two slices. The first contains no consecutive repeated elements. The second contains all the duplicates in no specified
order.

If the slice is sorted, the first returned slice contains no duplicates.

EXAMPLES

#![feature(slice_partition_dedup)]

let mut slice = [1, 2, 2, 3, 3, 2, 1, 1];

let (dedup, duplicates) = slice.partition_dedup();

assert_eq!(dedup, [1, 2, 3, 2, 1]);
assert_eq!(duplicates, [2, 3, 1]);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2886-2888]

PUB FN PARTITION_DEDUP_BY<F>(&MUT SELF, SAME_BUCKET: F) -> (&MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html],
&MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T, &MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

🔬This is a nightly-only experimental API. (slice_partition_dedup)

Moves all but the first of consecutive elements to the end of the slice satisfying a given equality relation.

Returns two slices. The first contains no consecutive repeated elements. The second contains all the duplicates in no specified
order.

The same_bucket function is passed references to two elements from the slice and must determine if the elements compare equal. The
elements are passed in opposite order from their order in the slice, so if same_bucket(a, b) returns true, a is moved at the end
of the slice.

If the slice is sorted, the first returned slice contains no duplicates.

EXAMPLES

#![feature(slice_partition_dedup)]

let mut slice = ["foo", "Foo", "BAZ", "Bar", "bar", "baz", "BAZ"];

let (dedup, duplicates) = slice.partition_dedup_by(|a, b| a.eq_ignore_ascii_case(b));

assert_eq!(dedup, ["foo", "BAZ", "Bar", "baz"]);
assert_eq!(duplicates, ["bar", "Foo", "BAZ"]);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3012-3015]

PUB FN PARTITION_DEDUP_BY_KEY<K, F>(&MUT SELF, KEY: F) -> (&MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html],
&MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> K,
    K: PARTIALEQ [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialEq.html]<K>,

🔬This is a nightly-only experimental API. (slice_partition_dedup)

Moves all but the first of consecutive elements to the end of the slice that resolve to the same key.

Returns two slices. The first contains no consecutive repeated elements. The second contains all the duplicates in no specified
order.

If the slice is sorted, the first returned slice contains no duplicates.

EXAMPLES

#![feature(slice_partition_dedup)]

let mut slice = [10, 20, 21, 30, 30, 20, 11, 13];

let (dedup, duplicates) = slice.partition_dedup_by_key(|i| *i / 10);

assert_eq!(dedup, [10, 20, 30, 20, 11]);
assert_eq!(duplicates, [21, 30, 13]);

1.26.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3051]

PUB FN ROTATE_LEFT(&MUT SELF, MID: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html])

Rotates the slice in-place such that the first mid elements of the slice move to the end while the last self.len() - mid elements
move to the front. After calling rotate_left, the element previously at index mid will become the first element in the slice.

PANICS

This function will panic if mid is greater than the length of the slice. Note that mid == self.len() does not panic and is a no-op
rotation.

COMPLEXITY

Takes linear (in self.len()) time.

EXAMPLES

let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];
a.rotate_left(2);
assert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);

Rotating a subslice:

let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];
a[1..5].rotate_left(1);
assert_eq!(a, ['a', 'c', 'd', 'e', 'b', 'f']);

1.26.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3094]

PUB FN ROTATE_RIGHT(&MUT SELF, K: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html])

Rotates the slice in-place such that the first self.len() - k elements of the slice move to the end while the last k elements move
to the front. After calling rotate_right, the element previously at index self.len() - k will become the first element in the
slice.

PANICS

This function will panic if k is greater than the length of the slice. Note that k == self.len() does not panic and is a no-op
rotation.

COMPLEXITY

Takes linear (in self.len()) time.

EXAMPLES

let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];
a.rotate_right(2);
assert_eq!(a, ['e', 'f', 'a', 'b', 'c', 'd']);

Rotate a subslice:

let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];
a[1..5].rotate_right(1);
assert_eq!(a, ['a', 'e', 'b', 'c', 'd', 'f']);

1.50.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3117-3119]

PUB FN FILL(&MUT SELF, VALUE: T)WHERE
    T: CLONE [https://doc.rust-lang.org/1.67.0/core/clone/trait.Clone.html],

Fills self with elements by cloning value.

EXAMPLES

let mut buf = vec![0; 10];
buf.fill(1);
assert_eq!(buf, vec![1; 10]);

1.51.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3141-3143]

PUB FN FILL_WITH<F>(&MUT SELF, F: F)WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html]() -> T,

Fills self with elements returned by calling a closure repeatedly.

This method uses a closure to create new values. If you’d rather Clone
[https://doc.rust-lang.org/1.67.0/core/clone/trait.Clone.html] a given value, use fill
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.fill]. If you want to use the Default
[https://doc.rust-lang.org/1.67.0/core/default/trait.Default.html] trait to generate values, you can pass Default::default
[https://doc.rust-lang.org/1.67.0/core/default/trait.Default.html#tymethod.default] as the argument.

EXAMPLES

let mut buf = vec![1; 10];
buf.fill_with(Default::default);
assert_eq!(buf, vec![0; 10]);

1.7.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3204-3206]

PUB FN CLONE_FROM_SLICE(&MUT SELF, SRC: &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])WHERE
    T: CLONE [https://doc.rust-lang.org/1.67.0/core/clone/trait.Clone.html],

Copies the elements from src into self.

The length of src must be the same as self.

PANICS

This function will panic if the two slices have different lengths.

EXAMPLES

Cloning two elements from a slice into another:

let src = [1, 2, 3, 4];
let mut dst = [0, 0];

// Because the slices have to be the same length,
// we slice the source slice from four elements
// to two. It will panic if we don't do this.
dst.clone_from_slice(&src[2..]);

assert_eq!(src, [1, 2, 3, 4]);
assert_eq!(dst, [3, 4]);

Rust enforces that there can only be one mutable reference with no immutable references to a particular piece of data in a
particular scope. Because of this, attempting to use clone_from_slice on a single slice will result in a compile failure:

ⓘ

let mut slice = [1, 2, 3, 4, 5];

slice[..2].clone_from_slice(&slice[3..]); // compile fail!

To work around this, we can use split_at_mut [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.split_at_mut] to
create two distinct sub-slices from a slice:

let mut slice = [1, 2, 3, 4, 5];

{
    let (left, right) = slice.split_at_mut(2);
    left.clone_from_slice(&right[1..]);
}

assert_eq!(slice, [4, 5, 3, 4, 5]);

1.9.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3268-3270]

PUB FN COPY_FROM_SLICE(&MUT SELF, SRC: &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])WHERE
    T: COPY [https://doc.rust-lang.org/1.67.0/core/marker/trait.Copy.html],

Copies all elements from src into self, using a memcpy.

The length of src must be the same as self.

If T does not implement Copy, use clone_from_slice
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.clone_from_slice].

PANICS

This function will panic if the two slices have different lengths.

EXAMPLES

Copying two elements from a slice into another:

let src = [1, 2, 3, 4];
let mut dst = [0, 0];

// Because the slices have to be the same length,
// we slice the source slice from four elements
// to two. It will panic if we don't do this.
dst.copy_from_slice(&src[2..]);

assert_eq!(src, [1, 2, 3, 4]);
assert_eq!(dst, [3, 4]);

Rust enforces that there can only be one mutable reference with no immutable references to a particular piece of data in a
particular scope. Because of this, attempting to use copy_from_slice on a single slice will result in a compile failure:

ⓘ

let mut slice = [1, 2, 3, 4, 5];

slice[..2].copy_from_slice(&slice[3..]); // compile fail!

To work around this, we can use split_at_mut [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.split_at_mut] to
create two distinct sub-slices from a slice:

let mut slice = [1, 2, 3, 4, 5];

{
    let (left, right) = slice.split_at_mut(2);
    left.copy_from_slice(&right[1..]);
}

assert_eq!(slice, [4, 5, 3, 4, 5]);

1.37.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3322-3324]

PUB FN COPY_WITHIN<R>(&MUT SELF, SRC: R, DEST: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html])WHERE
    R: RANGEBOUNDS [https://doc.rust-lang.org/1.67.0/core/ops/range/trait.RangeBounds.html]<USIZE
[https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>,
    T: COPY [https://doc.rust-lang.org/1.67.0/core/marker/trait.Copy.html],

Copies elements from one part of the slice to another part of itself, using a memmove.

src is the range within self to copy from. dest is the starting index of the range within self to copy to, which will have the
same length as src. The two ranges may overlap. The ends of the two ranges must be less than or equal to self.len().

PANICS

This function will panic if either range exceeds the end of the slice, or if the end of src is before the start.

EXAMPLES

Copying four bytes within a slice:

let mut bytes = *b"Hello, World!";

bytes.copy_within(1..5, 8);

assert_eq!(&bytes, b"Hello, Wello!");

1.27.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3389]

PUB FN SWAP_WITH_SLICE(&MUT SELF, OTHER: &MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])

Swaps all elements in self with those in other.

The length of other must be the same as self.

PANICS

This function will panic if the two slices have different lengths.

EXAMPLE

Swapping two elements across slices:

let mut slice1 = [0, 0];
let mut slice2 = [1, 2, 3, 4];

slice1.swap_with_slice(&mut slice2[2..]);

assert_eq!(slice1, [3, 4]);
assert_eq!(slice2, [1, 2, 0, 0]);

Rust enforces that there can only be one mutable reference to a particular piece of data in a particular scope. Because of this,
attempting to use swap_with_slice on a single slice will result in a compile failure:

ⓘ

let mut slice = [1, 2, 3, 4, 5];
slice[..2].swap_with_slice(&mut slice[3..]); // compile fail!

To work around this, we can use split_at_mut [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.split_at_mut] to
create two distinct mutable sub-slices from a slice:

let mut slice = [1, 2, 3, 4, 5];

{
    let (left, right) = slice.split_at_mut(2);
    left.swap_with_slice(&mut right[1..]);
}

assert_eq!(slice, [4, 5, 3, 1, 2]);

1.30.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3500]

PUB UNSAFE FN ALIGN_TO<U>(&SELF) -> (&[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &[U]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])

Transmute the slice to a slice of another type, ensuring alignment of the types is maintained.

This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix
slice. How exactly the slice is split up is not specified; the middle part may be smaller than necessary. However, if this fails
to return a maximal middle part, that is because code is running in a context where performance does not matter, such as a
sanitizer attempting to find alignment bugs. Regular code running in a default (debug or release) execution will return a maximal
middle part.

This method has no purpose when either input element T or output element U are zero-sized and will return the original slice
without splitting anything.

SAFETY

This method is essentially a transmute with respect to the elements in the returned middle slice, so all the usual caveats
pertaining to transmute::<T, U> also apply here.

EXAMPLES

Basic usage:

unsafe {
    let bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];
    let (prefix, shorts, suffix) = bytes.align_to::<u16>();
    // less_efficient_algorithm_for_bytes(prefix);
    // more_efficient_algorithm_for_aligned_shorts(shorts);
    // less_efficient_algorithm_for_bytes(suffix);
}

1.30.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3562]

PUB UNSAFE FN ALIGN_TO_MUT<U>(&MUT SELF) -> (&MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &MUT [U]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])

Transmute the mutable slice to a mutable slice of another type, ensuring alignment of the types is maintained.

This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix
slice. How exactly the slice is split up is not specified; the middle part may be smaller than necessary. However, if this fails
to return a maximal middle part, that is because code is running in a context where performance does not matter, such as a
sanitizer attempting to find alignment bugs. Regular code running in a default (debug or release) execution will return a maximal
middle part.

This method has no purpose when either input element T or output element U are zero-sized and will return the original slice
without splitting anything.

SAFETY

This method is essentially a transmute with respect to the elements in the returned middle slice, so all the usual caveats
pertaining to transmute::<T, U> also apply here.

EXAMPLES

Basic usage:

unsafe {
    let mut bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];
    let (prefix, shorts, suffix) = bytes.align_to_mut::<u16>();
    // less_efficient_algorithm_for_bytes(prefix);
    // more_efficient_algorithm_for_aligned_shorts(shorts);
    // less_efficient_algorithm_for_bytes(suffix);
}

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3657-3661]

PUB FN AS_SIMD<CONST LANES: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&SELF) -> (&[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &[SIMD
[https://doc.rust-lang.org/1.67.0/core/core_simd/vector/struct.Simd.html]<T, LANES>], &[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])WHERE
    SIMD [https://doc.rust-lang.org/1.67.0/core/core_simd/vector/struct.Simd.html]<T, LANES>: ASREF
[https://doc.rust-lang.org/1.67.0/core/convert/trait.AsRef.html]<[T; LANES]
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html]>,
    T: SIMDELEMENT [https://doc.rust-lang.org/1.67.0/core/core_simd/vector/trait.SimdElement.html],
    LANECOUNT [https://doc.rust-lang.org/1.67.0/core/core_simd/lane_count/struct.LaneCount.html]<LANES>: SUPPORTEDLANECOUNT
[https://doc.rust-lang.org/1.67.0/core/core_simd/lane_count/trait.SupportedLaneCount.html],

🔬This is a nightly-only experimental API. (portable_simd)

Split a slice into a prefix, a middle of aligned SIMD types, and a suffix.

This is a safe wrapper around slice::align_to [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.align_to], so has
the same weak postconditions as that method. You’re only assured that self.len() == prefix.len() + middle.len() * LANES +
suffix.len().

Notably, all of the following are possible:

 * prefix.len() >= LANES.
 * middle.is_empty() despite self.len() >= 3 * LANES.
 * suffix.len() >= LANES.

That said, this is a safe method, so if you’re only writing safe code, then this can at most cause incorrect logic, not
unsoundness.

PANICS

This will panic if the size of the SIMD type is different from LANES times that of the scalar.

At the time of writing, the trait restrictions on Simd<T, LANES> keeps that from ever happening, as only power-of-two numbers of
lanes are supported. It’s possible that, in the future, those restrictions might be lifted in a way that would make it possible to
see panics from this method for something like LANES == 3.

EXAMPLES

#![feature(portable_simd)]
use core::simd::SimdFloat;

let short = &[1, 2, 3];
let (prefix, middle, suffix) = short.as_simd::<4>();
assert_eq!(middle, []); // Not enough elements for anything in the middle

// They might be split in any possible way between prefix and suffix
let it = prefix.iter().chain(suffix).copied();
assert_eq!(it.collect::<Vec<_>>(), vec![1, 2, 3]);

fn basic_simd_sum(x: &[f32]) -> f32 {
    use std::ops::Add;
    use std::simd::f32x4;
    let (prefix, middle, suffix) = x.as_simd();
    let sums = f32x4::from_array([
        prefix.iter().copied().sum(),
        0.0,
        0.0,
        suffix.iter().copied().sum(),
    ]);
    let sums = middle.iter().copied().fold(sums, f32x4::add);
    sums.reduce_sum()
}

let numbers: Vec<f32> = (1..101).map(|x| x as _).collect();
assert_eq!(basic_simd_sum(&numbers[1..99]), 4949.0);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3702-3706]

PUB FN AS_SIMD_MUT<CONST LANES: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(
    &MUT SELF
) -> (&MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &MUT [SIMD
[https://doc.rust-lang.org/1.67.0/core/core_simd/vector/struct.Simd.html]<T, LANES>], &MUT [T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])WHERE
    SIMD [https://doc.rust-lang.org/1.67.0/core/core_simd/vector/struct.Simd.html]<T, LANES>: ASMUT
[https://doc.rust-lang.org/1.67.0/core/convert/trait.AsMut.html]<[T; LANES]
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html]>,
    T: SIMDELEMENT [https://doc.rust-lang.org/1.67.0/core/core_simd/vector/trait.SimdElement.html],
    LANECOUNT [https://doc.rust-lang.org/1.67.0/core/core_simd/lane_count/struct.LaneCount.html]<LANES>: SUPPORTEDLANECOUNT
[https://doc.rust-lang.org/1.67.0/core/core_simd/lane_count/trait.SupportedLaneCount.html],

🔬This is a nightly-only experimental API. (portable_simd)

Split a mutable slice into a mutable prefix, a middle of aligned SIMD types, and a mutable suffix.

This is a safe wrapper around slice::align_to_mut [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.align_to_mut],
so has the same weak postconditions as that method. You’re only assured that self.len() == prefix.len() + middle.len() * LANES +
suffix.len().

Notably, all of the following are possible:

 * prefix.len() >= LANES.
 * middle.is_empty() despite self.len() >= 3 * LANES.
 * suffix.len() >= LANES.

That said, this is a safe method, so if you’re only writing safe code, then this can at most cause incorrect logic, not
unsoundness.

This is the mutable version of slice::as_simd [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.as_simd]; see that
for examples.

PANICS

This will panic if the size of the SIMD type is different from LANES times that of the scalar.

At the time of writing, the trait restrictions on Simd<T, LANES> keeps that from ever happening, as only power-of-two numbers of
lanes are supported. It’s possible that, in the future, those restrictions might be lifted in a way that would make it possible to
see panics from this method for something like LANES == 3.

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3742-3744]

PUB FN IS_SORTED(&SELF) -> BOOL [https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]WHERE
    T: PARTIALORD [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialOrd.html]<T>,

🔬This is a nightly-only experimental API. (is_sorted)

Checks if the elements of this slice are sorted.

That is, for each element a and its following element b, a <= b must hold. If the slice yields exactly zero or one element, true
is returned.

Note that if Self::Item is only PartialOrd, but not Ord, the above definition implies that this function returns false if any two
consecutive items are not comparable.

EXAMPLES

#![feature(is_sorted)]
let empty: [i32; 0] = [];

assert!([1, 2, 2, 9].is_sorted());
assert!(![1, 3, 2, 4].is_sorted());
assert!([0].is_sorted());
assert!(empty.is_sorted());
assert!(![0.0, 1.0, f32::NAN].is_sorted());

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3758-3760]

PUB FN IS_SORTED_BY<'A, F>(&'A SELF, COMPARE: F) -> BOOL [https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&'A
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T, &'A
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> OPTION
[https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<ORDERING
[https://doc.rust-lang.org/1.67.0/core/cmp/enum.Ordering.html]>,

🔬This is a nightly-only experimental API. (is_sorted)

Checks if the elements of this slice are sorted using the given comparator function.

Instead of using PartialOrd::partial_cmp, this function uses the given compare function to determine the ordering of two elements.
Apart from that, it’s equivalent to is_sorted [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.is_sorted]; see
its documentation for more information.

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3784-3787]

PUB FN IS_SORTED_BY_KEY<'A, F, K>(&'A SELF, F: F) -> BOOL [https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&'A
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> K,
    K: PARTIALORD [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialOrd.html]<K>,

🔬This is a nightly-only experimental API. (is_sorted)

Checks if the elements of this slice are sorted using the given key extraction function.

Instead of comparing the slice’s elements directly, this function compares the keys of the elements, as determined by f. Apart
from that, it’s equivalent to is_sorted [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.is_sorted]; see its
documentation for more information.

EXAMPLES

#![feature(is_sorted)]

assert!(["c", "bb", "aaa"].is_sorted_by_key(|s| s.len()));
assert!(![-2i32, -1, 0, 3].is_sorted_by_key(|n| n.abs()));

1.52.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3843-3845]

PUB FN PARTITION_POINT<P>(&SELF, PRED: P) -> USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]WHERE
    P: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

Returns the index of the partition point according to the given predicate (the index of the first element of the second
partition).

The slice is assumed to be partitioned according to the given predicate. This means that all elements for which the predicate
returns true are at the start of the slice and all elements for which the predicate returns false are at the end. For example, [7,
15, 3, 5, 4, 12, 6] is a partitioned under the predicate x % 2 != 0 (all odd numbers are at the start, all even at the end).

If this slice is not partitioned, the returned result is unspecified and meaningless, as this method performs a kind of binary
search.

See also binary_search [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search], binary_search_by
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search_by], and binary_search_by_key
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search_by_key].

EXAMPLES

let v = [1, 2, 3, 3, 5, 6, 7];
let i = v.partition_point(|&x| x < 5);

assert_eq!(i, 4);
assert!(v[..i].iter().all(|&x| x < 5));
assert!(v[i..].iter().all(|&x| !(x < 5)));

If all elements of the slice match the predicate, including if the slice is empty, then the length of the slice will be returned:

let a = [2, 4, 8];
assert_eq!(a.partition_point(|x| x < &100), a.len());
let a: [i32; 0] = [];
assert_eq!(a.partition_point(|x| x < &100), 0);

If you want to insert an item to a sorted vector, while maintaining sort order:

let mut s = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];
let num = 42;
let idx = s.partition_point(|&x| x < num);
s.insert(idx, num);
assert_eq!(s, [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3901]

PUB FN TAKE<R, 'A>(SELF: &MUT &'A [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], RANGE: R) -> OPTION
[https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&'A [T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>WHERE
    R: ONESIDEDRANGE [https://doc.rust-lang.org/1.67.0/core/ops/range/trait.OneSidedRange.html]<USIZE
[https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>,

🔬This is a nightly-only experimental API. (slice_take)

Removes the subslice corresponding to the given range and returns a reference to it.

Returns None and does not modify the slice if the given range is out of bounds.

Note that this method only accepts one-sided ranges such as 2.. or ..6, but not 2..6.

EXAMPLES

Taking the first three elements of a slice:

#![feature(slice_take)]

let mut slice: &[_] = &['a', 'b', 'c', 'd'];
let mut first_three = slice.take(..3).unwrap();

assert_eq!(slice, &['d']);
assert_eq!(first_three, &['a', 'b', 'c']);

Taking the last two elements of a slice:

#![feature(slice_take)]

let mut slice: &[_] = &['a', 'b', 'c', 'd'];
let mut tail = slice.take(2..).unwrap();

assert_eq!(slice, &['a', 'b']);
assert_eq!(tail, &['c', 'd']);

Getting None when range is out of bounds:

#![feature(slice_take)]

let mut slice: &[_] = &['a', 'b', 'c', 'd'];

assert_eq!(None, slice.take(5..));
assert_eq!(None, slice.take(..5));
assert_eq!(None, slice.take(..=4));
let expected: &[char] = &['a', 'b', 'c', 'd'];
assert_eq!(Some(expected), slice.take(..4));

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3970-3973]

PUB FN TAKE_MUT<R, 'A>(SELF: &MUT &'A MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], RANGE: R) -> OPTION
[https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&'A MUT [T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>WHERE
    R: ONESIDEDRANGE [https://doc.rust-lang.org/1.67.0/core/ops/range/trait.OneSidedRange.html]<USIZE
[https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>,

🔬This is a nightly-only experimental API. (slice_take)

Removes the subslice corresponding to the given range and returns a mutable reference to it.

Returns None and does not modify the slice if the given range is out of bounds.

Note that this method only accepts one-sided ranges such as 2.. or ..6, but not 2..6.

EXAMPLES

Taking the first three elements of a slice:

#![feature(slice_take)]

let mut slice: &mut [_] = &mut ['a', 'b', 'c', 'd'];
let mut first_three = slice.take_mut(..3).unwrap();

assert_eq!(slice, &mut ['d']);
assert_eq!(first_three, &mut ['a', 'b', 'c']);

Taking the last two elements of a slice:

#![feature(slice_take)]

let mut slice: &mut [_] = &mut ['a', 'b', 'c', 'd'];
let mut tail = slice.take_mut(2..).unwrap();

assert_eq!(slice, &mut ['a', 'b']);
assert_eq!(tail, &mut ['c', 'd']);

Getting None when range is out of bounds:

#![feature(slice_take)]

let mut slice: &mut [_] = &mut ['a', 'b', 'c', 'd'];

assert_eq!(None, slice.take_mut(5..));
assert_eq!(None, slice.take_mut(..5));
assert_eq!(None, slice.take_mut(..=4));
let expected: &mut [_] = &mut ['a', 'b', 'c', 'd'];
assert_eq!(Some(expected), slice.take_mut(..4));

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#4009]

PUB FN TAKE_FIRST<'A>(SELF: &MUT &'A [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]) -> OPTION
[https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&'A
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T>

🔬This is a nightly-only experimental API. (slice_take)

Removes the first element of the slice and returns a reference to it.

Returns None if the slice is empty.

EXAMPLES

#![feature(slice_take)]

let mut slice: &[_] = &['a', 'b', 'c'];
let first = slice.take_first().unwrap();

assert_eq!(slice, &['b', 'c']);
assert_eq!(first, &'a');

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#4034]

PUB FN TAKE_FIRST_MUT<'A>(SELF: &MUT &'A MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]) -> OPTION
[https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&'A MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T>

🔬This is a nightly-only experimental API. (slice_take)

Removes the first element of the slice and returns a mutable reference to it.

Returns None if the slice is empty.

EXAMPLES

#![feature(slice_take)]

let mut slice: &mut [_] = &mut ['a', 'b', 'c'];
let first = slice.take_first_mut().unwrap();
*first = 'd';

assert_eq!(slice, &['b', 'c']);
assert_eq!(first, &'d');

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#4058]

PUB FN TAKE_LAST<'A>(SELF: &MUT &'A [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]) -> OPTION
[https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&'A
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T>

🔬This is a nightly-only experimental API. (slice_take)

Removes the last element of the slice and returns a reference to it.

Returns None if the slice is empty.

EXAMPLES

#![feature(slice_take)]

let mut slice: &[_] = &['a', 'b', 'c'];
let last = slice.take_last().unwrap();

assert_eq!(slice, &['a', 'b']);
assert_eq!(last, &'c');

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#4083]

PUB FN TAKE_LAST_MUT<'A>(SELF: &MUT &'A MUT [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]) -> OPTION
[https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&'A MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T>

🔬This is a nightly-only experimental API. (slice_take)

Removes the last element of the slice and returns a mutable reference to it.

Returns None if the slice is empty.

EXAMPLES

#![feature(slice_take)]

let mut slice: &mut [_] = &mut ['a', 'b', 'c'];
let last = slice.take_last_mut().unwrap();
*last = 'd';

assert_eq!(slice, &['a', 'b']);
assert_eq!(last, &'d');

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#4117-4120]

PUB UNSAFE FN GET_MANY_UNCHECKED_MUT<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(
    &MUT SELF,
    INDICES: [USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]; N
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html]]
) -> [&MUT [https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T; N
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html]]

🔬This is a nightly-only experimental API. (get_many_mut)

Returns mutable references to many indices at once, without doing any checks.

For a safe alternative see get_many_mut [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.get_many_mut].

SAFETY

Calling this method with overlapping or out-of-bounds indices is undefined behavior
[https://doc.rust-lang.org/reference/behavior-considered-undefined.html] even if the resulting references are not used.

EXAMPLES

#![feature(get_many_mut)]

let x = &mut [1, 2, 4];

unsafe {
    let [a, b] = x.get_many_unchecked_mut([0, 2]);
    *a *= 10;
    *b *= 100;
}
assert_eq!(x, &[10, 2, 400]);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#4159-4162]

PUB FN GET_MANY_MUT<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(
    &MUT SELF,
    INDICES: [USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]; N
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html]]
) -> RESULT [https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<[&MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T; N [https://doc.rust-lang.org/1.67.0/std/primitive.array.html]],
GETMANYMUTERROR [https://doc.rust-lang.org/1.67.0/core/slice/struct.GetManyMutError.html]<N>>

🔬This is a nightly-only experimental API. (get_many_mut)

Returns mutable references to many indices at once.

Returns an error if any index is out-of-bounds, or if the same index was passed more than once.

EXAMPLES

#![feature(get_many_mut)]

let v = &mut [1, 2, 3];
if let Ok([a, b]) = v.get_many_mut([0, 2]) {
    *a = 413;
    *b = 612;
}
assert_eq!(v, &[413, 2, 612]);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#4277]

PUB FN SORT_FLOATS(&MUT SELF)

🔬This is a nightly-only experimental API. (sort_floats)

Sorts the slice of floats.

This sort is in-place (i.e. does not allocate), O(n * log(n)) worst-case, and uses the ordering defined by f32::total_cmp
[https://doc.rust-lang.org/1.67.0/std/primitive.f32.html#method.total_cmp].

CURRENT IMPLEMENTATION

This uses the same sorting algorithm as sort_unstable_by
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.sort_unstable_by].

EXAMPLES

#![feature(sort_floats)]
let mut v = [2.6, -5e-8, f32::NAN, 8.29, f32::INFINITY, -1.0, 0.0, -f32::INFINITY, -0.0];

v.sort_floats();
let sorted = [-f32::INFINITY, -1.0, -5e-8, -0.0, 0.0, 2.6, 8.29, f32::INFINITY, f32::NAN];
assert_eq!(&v[..8], &sorted[..8]);
assert!(v[8].is_nan());

1.23.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#616]

PUB FN TO_ASCII_UPPERCASE(&SELF) -> VEC [https://doc.rust-lang.org/1.67.0/alloc/vec/struct.Vec.html]<U8
[https://doc.rust-lang.org/1.67.0/std/primitive.u8.html], GLOBAL
[https://doc.rust-lang.org/1.67.0/alloc/alloc/struct.Global.html]> Ⓘ

Returns a vector containing a copy of this slice where each byte is mapped to its ASCII upper case equivalent.

ASCII letters ‘a’ to ‘z’ are mapped to ‘A’ to ‘Z’, but non-ASCII letters are unchanged.

To uppercase the value in-place, use make_ascii_uppercase
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.make_ascii_uppercase].

1.23.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#637]

PUB FN TO_ASCII_LOWERCASE(&SELF) -> VEC [https://doc.rust-lang.org/1.67.0/alloc/vec/struct.Vec.html]<U8
[https://doc.rust-lang.org/1.67.0/std/primitive.u8.html], GLOBAL
[https://doc.rust-lang.org/1.67.0/alloc/alloc/struct.Global.html]> Ⓘ

Returns a vector containing a copy of this slice where each byte is mapped to its ASCII lower case equivalent.

ASCII letters ‘A’ to ‘Z’ are mapped to ‘a’ to ‘z’, but non-ASCII letters are unchanged.

To lowercase the value in-place, use make_ascii_lowercase
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.make_ascii_lowercase].

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#202-204]

PUB FN SORT(&MUT SELF)WHERE
    T: ORD [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html],

Sorts the slice.

This sort is stable (i.e., does not reorder equal elements) and O(n * log(n)) worst-case.

When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn’t allocate
auxiliary memory. See sort_unstable [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.sort_unstable].

CURRENT IMPLEMENTATION

The current algorithm is an adaptive, iterative merge sort inspired by timsort [https://en.wikipedia.org/wiki/Timsort]. It is
designed to be very fast in cases where the slice is nearly sorted, or consists of two or more sorted sequences concatenated one
after another.

Also, it allocates temporary storage half the size of self, but for short slices a non-allocating insertion sort is used instead.

EXAMPLES

let mut v = [-5, 4, 1, -3, 2];

v.sort();
assert!(v == [-5, -3, 1, 2, 4]);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#258-260]

PUB FN SORT_BY<F>(&MUT SELF, COMPARE: F)WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T, &
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> ORDERING
[https://doc.rust-lang.org/1.67.0/core/cmp/enum.Ordering.html],

Sorts the slice with a comparator function.

This sort is stable (i.e., does not reorder equal elements) and O(n * log(n)) worst-case.

The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the
elements is unspecified. An order is a total order if it is (for all a, b and c):

 * total and antisymmetric: exactly one of a < b, a == b or a > b is true, and
 * transitive, a < b and b < c implies a < c. The same must hold for both == and >.

For example, while f64 [https://doc.rust-lang.org/1.67.0/std/primitive.f64.html] doesn’t implement Ord
[https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html] because NaN != NaN, we can use partial_cmp as our sort function when we
know the slice doesn’t contain a NaN.

let mut floats = [5f64, 4.0, 1.0, 3.0, 2.0];
floats.sort_by(|a, b| a.partial_cmp(b).unwrap());
assert_eq!(floats, [1.0, 2.0, 3.0, 4.0, 5.0]);

When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn’t allocate
auxiliary memory. See sort_unstable_by [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.sort_unstable_by].

CURRENT IMPLEMENTATION

The current algorithm is an adaptive, iterative merge sort inspired by timsort [https://en.wikipedia.org/wiki/Timsort]. It is
designed to be very fast in cases where the slice is nearly sorted, or consists of two or more sorted sequences concatenated one
after another.

Also, it allocates temporary storage half the size of self, but for short slices a non-allocating insertion sort is used instead.

EXAMPLES

let mut v = [5, 4, 1, 3, 2];
v.sort_by(|a, b| a.cmp(b));
assert!(v == [1, 2, 3, 4, 5]);

// reverse sorting
v.sort_by(|a, b| b.cmp(a));
assert!(v == [5, 4, 3, 2, 1]);

1.7.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#300-303]

PUB FN SORT_BY_KEY<K, F>(&MUT SELF, F: F)WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> K,
    K: ORD [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html],

Sorts the slice with a key extraction function.

This sort is stable (i.e., does not reorder equal elements) and O(m * n * log(n)) worst-case, where the key function is O(m).

For expensive key functions (e.g. functions that are not simple property accesses or basic operations), sort_by_cached_key
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.sort_by_cached_key] is likely to be significantly faster, as it
does not recompute element keys.

When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn’t allocate
auxiliary memory. See sort_unstable_by_key
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.sort_unstable_by_key].

CURRENT IMPLEMENTATION

The current algorithm is an adaptive, iterative merge sort inspired by timsort [https://en.wikipedia.org/wiki/Timsort]. It is
designed to be very fast in cases where the slice is nearly sorted, or consists of two or more sorted sequences concatenated one
after another.

Also, it allocates temporary storage half the size of self, but for short slices a non-allocating insertion sort is used instead.

EXAMPLES

let mut v = [-5i32, 4, 1, -3, 2];

v.sort_by_key(|k| k.abs());
assert!(v == [1, 2, -3, 4, -5]);

1.34.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#347-350]

PUB FN SORT_BY_CACHED_KEY<K, F>(&MUT SELF, F: F)WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> K,
    K: ORD [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html],

Sorts the slice with a key extraction function.

During sorting, the key function is called at most once per element, by using temporary storage to remember the results of key
evaluation. The order of calls to the key function is unspecified and may change in future versions of the standard library.

This sort is stable (i.e., does not reorder equal elements) and O(m * n + n * log(n)) worst-case, where the key function is O(m).

For simple key functions (e.g., functions that are property accesses or basic operations), sort_by_key
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.sort_by_key] is likely to be faster.

CURRENT IMPLEMENTATION

The current algorithm is based on pattern-defeating quicksort [https://github.com/orlp/pdqsort] by Orson Peters, which combines
the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with
certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic
behavior.

In the worst case, the algorithm allocates temporary storage in a Vec<(K, usize)> the length of the slice.

EXAMPLES

let mut v = [-5i32, 4, 32, -3, 2];

v.sort_by_cached_key(|k| k.to_string());
assert!(v == [-3, -5, 2, 32, 4]);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#407-409]

PUB FN TO_VEC(&SELF) -> VEC [https://doc.rust-lang.org/1.67.0/alloc/vec/struct.Vec.html]<T, GLOBAL
[https://doc.rust-lang.org/1.67.0/alloc/alloc/struct.Global.html]> ⒾWHERE
    T: CLONE [https://doc.rust-lang.org/1.67.0/core/clone/trait.Clone.html],

Copies self into a new Vec.

EXAMPLES

let s = [10, 40, 30];
let x = s.to_vec();
// Here, `s` and `x` can be modified independently.

source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#431-433]

PUB FN TO_VEC_IN<A>(&SELF, ALLOC: A) -> VEC [https://doc.rust-lang.org/1.67.0/alloc/vec/struct.Vec.html]<T, A> ⒾWHERE
    A: ALLOCATOR [https://doc.rust-lang.org/1.67.0/core/alloc/trait.Allocator.html],
    T: CLONE [https://doc.rust-lang.org/1.67.0/core/clone/trait.Clone.html],

🔬This is a nightly-only experimental API. (allocator_api)

Copies self into a new Vec with an allocator.

EXAMPLES

#![feature(allocator_api)]

use std::alloc::System;

let s = [10, 40, 30];
let x = s.to_vec_in(System);
// Here, `s` and `x` can be modified independently.

1.40.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#484-486]

PUB FN REPEAT(&SELF, N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> VEC
[https://doc.rust-lang.org/1.67.0/alloc/vec/struct.Vec.html]<T, GLOBAL
[https://doc.rust-lang.org/1.67.0/alloc/alloc/struct.Global.html]> ⒾWHERE
    T: COPY [https://doc.rust-lang.org/1.67.0/core/marker/trait.Copy.html],

Creates a vector by copying a slice n times.

PANICS

This function will panic if the capacity would overflow.

EXAMPLES

Basic usage:

assert_eq!([1, 2].repeat(3), vec![1, 2, 1, 2, 1, 2]);

A panic upon overflow:

ⓘ

// this will panic at runtime
b"0123456789abcdef".repeat(usize::MAX);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#552-554]

PUB FN CONCAT<ITEM>(&SELF) -> <[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html] AS CONCAT
[https://doc.rust-lang.org/1.67.0/alloc/slice/trait.Concat.html]<ITEM>>::OUTPUT
[https://doc.rust-lang.org/1.67.0/alloc/slice/trait.Concat.html#associatedtype.Output] ⒾWHERE
    [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]: CONCAT
[https://doc.rust-lang.org/1.67.0/alloc/slice/trait.Concat.html]<ITEM>,
    ITEM: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

Flattens a slice of T into a single value Self::Output.

EXAMPLES

assert_eq!(["hello", "world"].concat(), "helloworld");
assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);

1.3.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#571-573]

PUB FN JOIN<SEPARATOR>(&SELF, SEP: SEPARATOR) -> <[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html] AS JOIN
[https://doc.rust-lang.org/1.67.0/alloc/slice/trait.Join.html]<SEPARATOR>>::OUTPUT
[https://doc.rust-lang.org/1.67.0/alloc/slice/trait.Join.html#associatedtype.Output] ⒾWHERE
    [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]: JOIN
[https://doc.rust-lang.org/1.67.0/alloc/slice/trait.Join.html]<SEPARATOR>,

Flattens a slice of T into a single value Self::Output, placing a given separator between each.

EXAMPLES

assert_eq!(["hello", "world"].join(" "), "hello world");
assert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);
assert_eq!([[1, 2], [3, 4]].join(&[0, 0][..]), [1, 2, 0, 0, 3, 4]);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#591-593]

PUB FN CONNECT<SEPARATOR>(
    &SELF,
    SEP: SEPARATOR
) -> <[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html] AS JOIN
[https://doc.rust-lang.org/1.67.0/alloc/slice/trait.Join.html]<SEPARATOR>>::OUTPUT
[https://doc.rust-lang.org/1.67.0/alloc/slice/trait.Join.html#associatedtype.Output] ⒾWHERE
    [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]: JOIN
[https://doc.rust-lang.org/1.67.0/alloc/slice/trait.Join.html]<SEPARATOR>,

👎Deprecated since 1.3.0: renamed to join

Flattens a slice of T into a single value Self::Output, placing a given separator between each.

EXAMPLES

assert_eq!(["hello", "world"].connect(" "), "hello world");
assert_eq!([[1, 2], [3, 4]].connect(&0), [1, 2, 0, 3, 4]);


TRAIT IMPLEMENTATIONS§

source [../src/fedimint_ln_server/lib.rs.html#57-102]§


IMPL DEREF [https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.Deref.html] FOR AMOUNTS_BUCKETS_SATS
[struct.AMOUNTS_BUCKETS_SATS.html]

§

TYPE TARGET [https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.Deref.html#associatedtype.Target] = VEC
[https://doc.rust-lang.org/1.67.0/alloc/vec/struct.Vec.html]<F64 [https://doc.rust-lang.org/1.67.0/std/primitive.f64.html], GLOBAL
[https://doc.rust-lang.org/1.67.0/alloc/alloc/struct.Global.html]>

The resulting type after dereferencing.
source [../src/fedimint_ln_server/lib.rs.html#57-102]§

FN DEREF [https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.Deref.html#tymethod.deref](&SELF) -> &VEC
[https://doc.rust-lang.org/1.67.0/alloc/vec/struct.Vec.html]<F64 [https://doc.rust-lang.org/1.67.0/std/primitive.f64.html]> Ⓘ

Dereferences the value.
source [../src/fedimint_ln_server/lib.rs.html#57-102]§


IMPL LAZYSTATIC [https://docs.rs/lazy_static/1.4.0/lazy_static/trait.LazyStatic.html] FOR AMOUNTS_BUCKETS_SATS
[struct.AMOUNTS_BUCKETS_SATS.html]


AUTO TRAIT IMPLEMENTATIONS§

§


IMPL REFUNWINDSAFE [https://doc.rust-lang.org/1.67.0/core/panic/unwind_safe/trait.RefUnwindSafe.html] FOR AMOUNTS_BUCKETS_SATS
[struct.AMOUNTS_BUCKETS_SATS.html]

§


IMPL SEND [https://doc.rust-lang.org/1.67.0/core/marker/trait.Send.html] FOR AMOUNTS_BUCKETS_SATS
[struct.AMOUNTS_BUCKETS_SATS.html]

§


IMPL SYNC [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sync.html] FOR AMOUNTS_BUCKETS_SATS
[struct.AMOUNTS_BUCKETS_SATS.html]

§


IMPL UNPIN [https://doc.rust-lang.org/1.67.0/core/marker/trait.Unpin.html] FOR AMOUNTS_BUCKETS_SATS
[struct.AMOUNTS_BUCKETS_SATS.html]

§


IMPL UNWINDSAFE [https://doc.rust-lang.org/1.67.0/core/panic/unwind_safe/trait.UnwindSafe.html] FOR AMOUNTS_BUCKETS_SATS
[struct.AMOUNTS_BUCKETS_SATS.html]


BLANKET IMPLEMENTATIONS§

source [https://doc.rust-lang.org/1.67.0/src/core/any.rs.html#200]§


IMPL<T> ANY [https://doc.rust-lang.org/1.67.0/core/any/trait.Any.html] FOR TWHERE
    T: 'STATIC + ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

source [https://doc.rust-lang.org/1.67.0/src/core/any.rs.html#201]§

FN TYPE_ID [https://doc.rust-lang.org/1.67.0/core/any/trait.Any.html#tymethod.type_id](&SELF) -> TYPEID
[https://doc.rust-lang.org/1.67.0/core/any/struct.TypeId.html]

Gets the TypeId of self. Read more [https://doc.rust-lang.org/1.67.0/core/any/trait.Any.html#tymethod.type_id]
source [https://doc.rust-lang.org/1.67.0/src/core/borrow.rs.html#211]§


IMPL<T> BORROW [https://doc.rust-lang.org/1.67.0/core/borrow/trait.Borrow.html]<T> FOR TWHERE
    T: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

const: unstable [https://github.com/rust-lang/rust/issues/91522] · source
[https://doc.rust-lang.org/1.67.0/src/core/borrow.rs.html#213]§

FN BORROW [https://doc.rust-lang.org/1.67.0/core/borrow/trait.Borrow.html#tymethod.borrow](&SELF) -> &
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T

Immutably borrows from an owned value. Read more [https://doc.rust-lang.org/1.67.0/core/borrow/trait.Borrow.html#tymethod.borrow]
source [https://doc.rust-lang.org/1.67.0/src/core/borrow.rs.html#220]§


IMPL<T> BORROWMUT [https://doc.rust-lang.org/1.67.0/core/borrow/trait.BorrowMut.html]<T> FOR TWHERE
    T: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

const: unstable [https://github.com/rust-lang/rust/issues/91522] · source
[https://doc.rust-lang.org/1.67.0/src/core/borrow.rs.html#221]§

FN BORROW_MUT [https://doc.rust-lang.org/1.67.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut](&MUT SELF) -> &MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T

Mutably borrows from an owned value. Read more
[https://doc.rust-lang.org/1.67.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut]
§


IMPL<T> CONV FOR T

§

FN CONV<T>(SELF) -> TWHERE
    SELF: INTO [https://doc.rust-lang.org/1.67.0/core/convert/trait.Into.html]<T>,

Converts self into T using Into<T>. Read more
§


IMPL<T> FMTFORWARD FOR T

§

FN FMT_BINARY(SELF) -> FMTBINARY<SELF>WHERE
    SELF: BINARY [https://doc.rust-lang.org/1.67.0/core/fmt/trait.Binary.html],

Causes self to use its Binary implementation when Debug-formatted.
§

FN FMT_DISPLAY(SELF) -> FMTDISPLAY<SELF>WHERE
    SELF: DISPLAY [https://doc.rust-lang.org/1.67.0/core/fmt/trait.Display.html],

Causes self to use its Display implementation when Debug-formatted. Read more
§

FN FMT_LOWER_EXP(SELF) -> FMTLOWEREXP<SELF>WHERE
    SELF: LOWEREXP [https://doc.rust-lang.org/1.67.0/core/fmt/trait.LowerExp.html],

Causes self to use its LowerExp implementation when Debug-formatted. Read more
§

FN FMT_LOWER_HEX(SELF) -> FMTLOWERHEX<SELF>WHERE
    SELF: LOWERHEX [https://doc.rust-lang.org/1.67.0/core/fmt/trait.LowerHex.html],

Causes self to use its LowerHex implementation when Debug-formatted. Read more
§

FN FMT_OCTAL(SELF) -> FMTOCTAL<SELF>WHERE
    SELF: OCTAL [https://doc.rust-lang.org/1.67.0/core/fmt/trait.Octal.html],

Causes self to use its Octal implementation when Debug-formatted.
§

FN FMT_POINTER(SELF) -> FMTPOINTER<SELF>WHERE
    SELF: POINTER [https://doc.rust-lang.org/1.67.0/core/fmt/trait.Pointer.html],

Causes self to use its Pointer implementation when Debug-formatted. Read more
§

FN FMT_UPPER_EXP(SELF) -> FMTUPPEREXP<SELF>WHERE
    SELF: UPPEREXP [https://doc.rust-lang.org/1.67.0/core/fmt/trait.UpperExp.html],

Causes self to use its UpperExp implementation when Debug-formatted. Read more
§

FN FMT_UPPER_HEX(SELF) -> FMTUPPERHEX<SELF>WHERE
    SELF: UPPERHEX [https://doc.rust-lang.org/1.67.0/core/fmt/trait.UpperHex.html],

Causes self to use its UpperHex implementation when Debug-formatted. Read more
§

FN FMT_LIST(SELF) -> FMTLIST<SELF>WHERE
    &'A [https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]SELF: FOR<'A> INTOITERATOR
[https://doc.rust-lang.org/1.67.0/core/iter/traits/collect/trait.IntoIterator.html],

Formats each item in a sequence. Read more
source [https://doc.rust-lang.org/1.67.0/src/core/convert/mod.rs.html#733]§


IMPL<T> FROM [https://doc.rust-lang.org/1.67.0/core/convert/trait.From.html]<T> FOR T

const: unstable [https://github.com/rust-lang/rust/issues/88674] · source
[https://doc.rust-lang.org/1.67.0/src/core/convert/mod.rs.html#736]§

FN FROM [https://doc.rust-lang.org/1.67.0/core/convert/trait.From.html#tymethod.from](T: T) -> T

Returns the argument unchanged.

§


IMPL<T> FUTUREEXT FOR T

§

FN WITH_CONTEXT(SELF, OTEL_CX: CONTEXT) -> WITHCONTEXT<SELF>

Attaches the provided Context [crate::Context] to this type, returning a WithContext wrapper. Read more
§

FN WITH_CURRENT_CONTEXT(SELF) -> WITHCONTEXT<SELF>

Attaches the current Context [crate::Context] to this type, returning a WithContext wrapper. Read more
source [https://docs.rs/tracing/0.1.37/src/tracing/instrument.rs.html#276]§


IMPL<T> INSTRUMENT [https://docs.rs/tracing/0.1.37/tracing/instrument/trait.Instrument.html] FOR T

source [https://docs.rs/tracing/0.1.37/src/tracing/instrument.rs.html#82]§

FN INSTRUMENT [https://docs.rs/tracing/0.1.37/tracing/instrument/trait.Instrument.html#method.instrument](SELF, SPAN: SPAN
[https://docs.rs/tracing/0.1.37/tracing/span/struct.Span.html]) -> INSTRUMENTED
[https://docs.rs/tracing/0.1.37/tracing/instrument/struct.Instrumented.html]<SELF>

Instruments this type with the provided Span [https://docs.rs/tracing/0.1.37/tracing/span/struct.Span.html], returning an
Instrumented wrapper. Read more [https://docs.rs/tracing/0.1.37/tracing/instrument/trait.Instrument.html#method.instrument]
source [https://docs.rs/tracing/0.1.37/src/tracing/instrument.rs.html#121]§

FN IN_CURRENT_SPAN [https://docs.rs/tracing/0.1.37/tracing/instrument/trait.Instrument.html#method.in_current_span](SELF) ->
INSTRUMENTED [https://docs.rs/tracing/0.1.37/tracing/instrument/struct.Instrumented.html]<SELF>

Instruments this type with the current [https://docs.rs/tracing/0.1.37/tracing/span/struct.Span.html#method.current] Span
[https://docs.rs/tracing/0.1.37/tracing/span/struct.Span.html], returning an Instrumented wrapper. Read more
[https://docs.rs/tracing/0.1.37/tracing/instrument/trait.Instrument.html#method.in_current_span]
source [https://doc.rust-lang.org/1.67.0/src/core/convert/mod.rs.html#717]§


IMPL<T, U> INTO [https://doc.rust-lang.org/1.67.0/core/convert/trait.Into.html]<U> FOR TWHERE
    U: FROM [https://doc.rust-lang.org/1.67.0/core/convert/trait.From.html]<T>,

const: unstable [https://github.com/rust-lang/rust/issues/88674] · source
[https://doc.rust-lang.org/1.67.0/src/core/convert/mod.rs.html#725]§

FN INTO [https://doc.rust-lang.org/1.67.0/core/convert/trait.Into.html#tymethod.into](SELF) -> U

Calls U::from(self).

That is, this conversion is whatever the implementation of From [https://doc.rust-lang.org/1.67.0/core/convert/trait.From.html]<T>
for U chooses to do.

source [https://docs.rs/tonic/0.9.2/src/tonic/request.rs.html#384]§


IMPL<T> INTOREQUEST [https://docs.rs/tonic/0.9.2/tonic/request/trait.IntoRequest.html]<T> FOR T

source [https://docs.rs/tonic/0.9.2/src/tonic/request.rs.html#385]§

FN INTO_REQUEST [https://docs.rs/tonic/0.9.2/tonic/request/trait.IntoRequest.html#tymethod.into_request](SELF) -> REQUEST
[https://docs.rs/tonic/0.9.2/tonic/request/struct.Request.html]<T>

Wrap the input message T in a tonic::Request
§


IMPL<T> PIPE FOR TWHERE
    T: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

§

FN PIPE<R>(SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](SELF) -> R) -> RWHERE
    SELF: SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

Pipes by value. This is generally the method you want to use. Read more
§

FN PIPE_REF<'A, R>(&'A SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&'A
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]SELF) -> R) -> RWHERE
    R: 'A,

Borrows self and passes that borrow into the pipe function. Read more
§

FN PIPE_REF_MUT<'A, R>(&'A MUT SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&'A
MUT [https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]SELF) -> R) -> RWHERE
    R: 'A,

Mutably borrows self and passes that borrow into the pipe function. Read more
§

FN PIPE_BORROW<'A, B, R>(&'A SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&'A
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]B) -> R) -> RWHERE
    SELF: BORROW [https://doc.rust-lang.org/1.67.0/core/borrow/trait.Borrow.html]<B>,
    B: 'A + ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],
    R: 'A,

Borrows self, then passes self.borrow() into the pipe function. Read more
§

FN PIPE_BORROW_MUT<'A, B, R>(
    &'A MUT SELF,
    FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&'A MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]B) -> R
) -> RWHERE
    SELF: BORROWMUT [https://doc.rust-lang.org/1.67.0/core/borrow/trait.BorrowMut.html]<B>,
    B: 'A + ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],
    R: 'A,

Mutably borrows self, then passes self.borrow_mut() into the pipe function. Read more
§

FN PIPE_AS_REF<'A, U, R>(&'A SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&'A
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]U) -> R) -> RWHERE
    SELF: ASREF [https://doc.rust-lang.org/1.67.0/core/convert/trait.AsRef.html]<U>,
    U: 'A + ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],
    R: 'A,

Borrows self, then passes self.as_ref() into the pipe function.
§

FN PIPE_AS_MUT<'A, U, R>(&'A MUT SELF, FUNC: IMPL FNONCE
[https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&'A MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]U) -> R) -> RWHERE
    SELF: ASMUT [https://doc.rust-lang.org/1.67.0/core/convert/trait.AsMut.html]<U>,
    U: 'A + ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],
    R: 'A,

Mutably borrows self, then passes self.as_mut() into the pipe function. Read more
§

FN PIPE_DEREF<'A, T, R>(&'A SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&'A
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> R) -> RWHERE
    SELF: DEREF [https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.Deref.html]<TARGET = T>,
    T: 'A + ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],
    R: 'A,

Borrows self, then passes self.deref() into the pipe function.
§

FN PIPE_DEREF_MUT<'A, T, R>(&'A MUT SELF, FUNC: IMPL FNONCE
[https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&'A MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> R) -> RWHERE
    SELF: DEREFMUT [https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.DerefMut.html]<TARGET = T> + DEREF
[https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.Deref.html],
    T: 'A + ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],
    R: 'A,

Mutably borrows self, then passes self.deref_mut() into the pipe function. Read more
source [https://docs.rs/typenum/1.16.0/src/typenum/type_operators.rs.html#34]§


IMPL<T> SAME [https://docs.rs/typenum/1.16.0/typenum/type_operators/trait.Same.html]<T> FOR T

§

TYPE OUTPUT [https://docs.rs/typenum/1.16.0/typenum/type_operators/trait.Same.html#associatedtype.Output] = T

Should always be Self
§


IMPL<T> TAP FOR T

§

FN TAP(SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]SELF)) -> SELF

Immutable access to a value. Read more
§

FN TAP_MUT(SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]SELF)) -> SELF

Mutable access to a value. Read more
§

FN TAP_BORROW<B>(SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]B)) -> SELFWHERE
    SELF: BORROW [https://doc.rust-lang.org/1.67.0/core/borrow/trait.Borrow.html]<B>,
    B: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

Immutable access to the Borrow<B> of a value. Read more
§

FN TAP_BORROW_MUT<B>(SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]B)) -> SELFWHERE
    SELF: BORROWMUT [https://doc.rust-lang.org/1.67.0/core/borrow/trait.BorrowMut.html]<B>,
    B: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

Mutable access to the BorrowMut<B> of a value. Read more
§

FN TAP_REF<R>(SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]R)) -> SELFWHERE
    SELF: ASREF [https://doc.rust-lang.org/1.67.0/core/convert/trait.AsRef.html]<R>,
    R: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

Immutable access to the AsRef<R> view of a value. Read more
§

FN TAP_REF_MUT<R>(SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]R)) -> SELFWHERE
    SELF: ASMUT [https://doc.rust-lang.org/1.67.0/core/convert/trait.AsMut.html]<R>,
    R: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

Mutable access to the AsMut<R> view of a value. Read more
§

FN TAP_DEREF<T>(SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T)) -> SELFWHERE
    SELF: DEREF [https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.Deref.html]<TARGET = T>,
    T: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

Immutable access to the Deref::Target of a value. Read more
§

FN TAP_DEREF_MUT<T>(SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T)) -> SELFWHERE
    SELF: DEREFMUT [https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.DerefMut.html]<TARGET = T> + DEREF
[https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.Deref.html],
    T: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

Mutable access to the Deref::Target of a value. Read more
§

FN TAP_DBG(SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]SELF)) -> SELF

Calls .tap() only in debug builds, and is erased in release builds.
§

FN TAP_MUT_DBG(SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]SELF)) -> SELF

Calls .tap_mut() only in debug builds, and is erased in release builds. Read more
§

FN TAP_BORROW_DBG<B>(SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]B)) -> SELFWHERE
    SELF: BORROW [https://doc.rust-lang.org/1.67.0/core/borrow/trait.Borrow.html]<B>,
    B: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

Calls .tap_borrow() only in debug builds, and is erased in release builds. Read more
§

FN TAP_BORROW_MUT_DBG<B>(SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]B)) -> SELFWHERE
    SELF: BORROWMUT [https://doc.rust-lang.org/1.67.0/core/borrow/trait.BorrowMut.html]<B>,
    B: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

Calls .tap_borrow_mut() only in debug builds, and is erased in release builds. Read more
§

FN TAP_REF_DBG<R>(SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]R)) -> SELFWHERE
    SELF: ASREF [https://doc.rust-lang.org/1.67.0/core/convert/trait.AsRef.html]<R>,
    R: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

Calls .tap_ref() only in debug builds, and is erased in release builds. Read more
§

FN TAP_REF_MUT_DBG<R>(SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]R)) -> SELFWHERE
    SELF: ASMUT [https://doc.rust-lang.org/1.67.0/core/convert/trait.AsMut.html]<R>,
    R: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

Calls .tap_ref_mut() only in debug builds, and is erased in release builds. Read more
§

FN TAP_DEREF_DBG<T>(SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T)) -> SELFWHERE
    SELF: DEREF [https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.Deref.html]<TARGET = T>,
    T: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

Calls .tap_deref() only in debug builds, and is erased in release builds. Read more
§

FN TAP_DEREF_MUT_DBG<T>(SELF, FUNC: IMPL FNONCE [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnOnce.html](&MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T)) -> SELFWHERE
    SELF: DEREFMUT [https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.DerefMut.html]<TARGET = T> + DEREF
[https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.Deref.html],
    T: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

Calls .tap_deref_mut() only in debug builds, and is erased in release builds. Read more
§


IMPL<T> TRYCONV FOR T

§

FN TRY_CONV<T>(SELF) -> RESULT [https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<T, SELF::ERROR
[https://doc.rust-lang.org/1.67.0/core/convert/trait.TryInto.html#associatedtype.Error]>WHERE
    SELF: TRYINTO [https://doc.rust-lang.org/1.67.0/core/convert/trait.TryInto.html]<T>,

Attempts to convert self into T using TryInto<T>. Read more
source [https://doc.rust-lang.org/1.67.0/src/core/convert/mod.rs.html#775]§


IMPL<T, U> TRYFROM [https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html]<U> FOR TWHERE
    U: INTO [https://doc.rust-lang.org/1.67.0/core/convert/trait.Into.html]<T>,

§

TYPE ERROR [https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html#associatedtype.Error] = INFALLIBLE
[https://doc.rust-lang.org/1.67.0/core/convert/enum.Infallible.html]

The type returned in the event of a conversion error.
const: unstable [https://github.com/rust-lang/rust/issues/88674] · source
[https://doc.rust-lang.org/1.67.0/src/core/convert/mod.rs.html#781]§

FN TRY_FROM [https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html#tymethod.try_from](VALUE: U) -> RESULT
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<T, <T AS TRYFROM
[https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html]<U>>::ERROR
[https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html#associatedtype.Error]>

Performs the conversion.
source [https://doc.rust-lang.org/1.67.0/src/core/convert/mod.rs.html#760]§


IMPL<T, U> TRYINTO [https://doc.rust-lang.org/1.67.0/core/convert/trait.TryInto.html]<U> FOR TWHERE
    U: TRYFROM [https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html]<T>,

§

TYPE ERROR [https://doc.rust-lang.org/1.67.0/core/convert/trait.TryInto.html#associatedtype.Error] = <U AS TRYFROM
[https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html]<T>>::ERROR
[https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html#associatedtype.Error]

The type returned in the event of a conversion error.
const: unstable [https://github.com/rust-lang/rust/issues/88674] · source
[https://doc.rust-lang.org/1.67.0/src/core/convert/mod.rs.html#766]§

FN TRY_INTO [https://doc.rust-lang.org/1.67.0/core/convert/trait.TryInto.html#tymethod.try_into](SELF) -> RESULT
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<U, <U AS TRYFROM
[https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html]<T>>::ERROR
[https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html#associatedtype.Error]>

Performs the conversion.
§


IMPL<V, T> VZIP<V> FOR TWHERE
    V: MULTILANE<T>,

§

FN VZIP(SELF) -> V

source [https://docs.rs/tracing/0.1.37/src/tracing/instrument.rs.html#334]§


IMPL<T> WITHSUBSCRIBER [https://docs.rs/tracing/0.1.37/tracing/instrument/trait.WithSubscriber.html] FOR T

source [https://docs.rs/tracing/0.1.37/src/tracing/instrument.rs.html#169-171]§

FN WITH_SUBSCRIBER [https://docs.rs/tracing/0.1.37/tracing/instrument/trait.WithSubscriber.html#method.with_subscriber]<S>(SELF,
SUBSCRIBER: S) -> WITHDISPATCH [https://docs.rs/tracing/0.1.37/tracing/instrument/struct.WithDispatch.html]<SELF>WHERE
    S: INTO [https://doc.rust-lang.org/1.67.0/core/convert/trait.Into.html]<DISPATCH
[https://docs.rs/tracing-core/0.1.22/tracing_core/dispatcher/struct.Dispatch.html]>,

Attaches the provided Subscriber [https://docs.rs/tracing-core/0.1.22/tracing_core/subscriber/trait.Subscriber.html] to this type,
returning a WithDispatch [https://docs.rs/tracing/0.1.37/tracing/instrument/struct.WithDispatch.html] wrapper. Read more
[https://docs.rs/tracing/0.1.37/tracing/instrument/trait.WithSubscriber.html#method.with_subscriber]
source [https://docs.rs/tracing/0.1.37/src/tracing/instrument.rs.html#221]§

FN WITH_CURRENT_SUBSCRIBER
[https://docs.rs/tracing/0.1.37/tracing/instrument/trait.WithSubscriber.html#method.with_current_subscriber](SELF) -> WITHDISPATCH
[https://docs.rs/tracing/0.1.37/tracing/instrument/struct.WithDispatch.html]<SELF>

Attaches the current default [https://docs.rs/tracing/0.1.37/tracing/dispatcher/index.html#setting-the-default-subscriber]
Subscriber [https://docs.rs/tracing-core/0.1.22/tracing_core/subscriber/trait.Subscriber.html] to this type, returning a
WithDispatch [https://docs.rs/tracing/0.1.37/tracing/instrument/struct.WithDispatch.html] wrapper. Read more
[https://docs.rs/tracing/0.1.37/tracing/instrument/trait.WithSubscriber.html#method.with_current_subscriber]
§


IMPL<T> MAYBESEND FOR TWHERE
    T: SEND [https://doc.rust-lang.org/1.67.0/core/marker/trait.Send.html],

§


IMPL<T> MAYBESEND FOR TWHERE
    T: SEND [https://doc.rust-lang.org/1.67.0/core/marker/trait.Send.html],

§


IMPL<T> MAYBESYNC FOR TWHERE
    T: SYNC [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sync.html],

