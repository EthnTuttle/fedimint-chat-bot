☰
logo [../../static.files/rust-logo-151179464ae7ed46.svg]
../../hkdf/index.html




logo [../../static.files/rust-logo-151179464ae7ed46.svg]
../../hkdf/index.html


SHA512


METHODS FROM DEREF<TARGET=[U8]>

 * align_to
 * array_chunks
 * array_windows
 * as_chunks
 * as_chunks_unchecked
 * as_ptr
 * as_ptr_range
 * as_rchunks
 * as_simd
 * binary_search
 * binary_search_by
 * binary_search_by_key
 * chunks
 * chunks_exact
 * concat
 * connect
 * contains
 * ends_with
 * eq_ignore_ascii_case
 * escape_ascii
 * first
 * flatten
 * get
 * get_unchecked
 * group_by
 * is_ascii
 * is_empty
 * is_sorted
 * is_sorted_by
 * is_sorted_by_key
 * iter
 * join
 * last
 * len
 * partition_point
 * rchunks
 * rchunks_exact
 * repeat
 * rsplit
 * rsplit_array_ref
 * rsplitn
 * split
 * split_array_ref
 * split_at
 * split_at_unchecked
 * split_first
 * split_inclusive
 * split_last
 * splitn
 * starts_with
 * strip_prefix
 * strip_suffix
 * to_ascii_lowercase
 * to_ascii_uppercase
 * to_vec
 * to_vec_in
 * trim_ascii
 * trim_ascii_end
 * trim_ascii_start
 * windows


TRAIT IMPLEMENTATIONS

 * AsRef<[u8]>
 * Borrow<[u8]>
 * Clone
 * Copy
 * Debug
 * Default
 * Deref
 * Deserialize<'de>
 * Display
 * Eq
 * FromStr
 * Hash
 * Hash
 * Index<I>
 * LowerHex
 * Ord
 * PartialEq<Hash>
 * PartialOrd<Hash>
 * SerdeHash
 * Serialize


AUTO TRAIT IMPLEMENTATIONS

 * RefUnwindSafe
 * Send
 * Sync
 * Unpin
 * UnwindSafe


BLANKET IMPLEMENTATIONS

 * Any
 * Borrow<T>
 * BorrowMut<T>
 * DeserializeOwned
 * From<T>
 * FromHex
 * Into<U>
 * ToHex
 * ToOwned
 * ToString
 * TryFrom<U>
 * TryInto<U>


IN HKDF::HASHES [index.html]

? [../../help.html]
Change settings [../../static.files/wheel-5ec35bf9ca753509.svg]../../settings.html


STRUCT HKDF [../index.html]::HASHES [index.html]::SHA512Copy item path [../../static.files/clipboard-7571035ce49a181d.svg]

[−]

pub struct Sha512(_);

Expand description

Output of the SHA256 hash function.


METHODS FROM DEREF [https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.Deref.html]<TARGET = [U8
[https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]]>§

1.23.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/ascii.rs.html#15]

PUB FN IS_ASCII(&SELF) -> BOOL [https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]

Checks if all bytes in this slice are within the ASCII range.

1.23.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/ascii.rs.html#26]

PUB FN EQ_IGNORE_ASCII_CASE(&SELF, OTHER: &[U8 [https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]]) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]

Checks that two slices are an ASCII case-insensitive match.

Same as to_ascii_lowercase(a) == to_ascii_lowercase(b), but without allocating and copying temporaries.

1.60.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/ascii.rs.html#78]

PUB FN ESCAPE_ASCII(&SELF) -> ESCAPEASCII [https://doc.rust-lang.org/1.67.0/core/slice/ascii/struct.EscapeAscii.html]<'_>

Returns an iterator that produces an escaped version of this slice, treating it as an ASCII string.

EXAMPLES


let s = b"0\t\r\n'\"\\\x9d";
let escaped = s.escape_ascii().to_string();
assert_eq!(escaped, "0\\t\\r\\n\\'\\\"\\\\\\x9d");

source [https://doc.rust-lang.org/1.67.0/src/core/slice/ascii.rs.html#97]

PUB FN TRIM_ASCII_START(&SELF) -> &[U8 [https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]] Ⓘ

🔬This is a nightly-only experimental API. (byte_slice_trim_ascii)

Returns a byte slice with leading ASCII whitespace bytes removed.

‘Whitespace’ refers to the definition used by u8::is_ascii_whitespace.

EXAMPLES

#![feature(byte_slice_trim_ascii)]

assert_eq!(b" \t hello world\n".trim_ascii_start(), b"hello world\n");
assert_eq!(b"  ".trim_ascii_start(), b"");
assert_eq!(b"".trim_ascii_start(), b"");

source [https://doc.rust-lang.org/1.67.0/src/core/slice/ascii.rs.html#126]

PUB FN TRIM_ASCII_END(&SELF) -> &[U8 [https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]] Ⓘ

🔬This is a nightly-only experimental API. (byte_slice_trim_ascii)

Returns a byte slice with trailing ASCII whitespace bytes removed.

‘Whitespace’ refers to the definition used by u8::is_ascii_whitespace.

EXAMPLES

#![feature(byte_slice_trim_ascii)]

assert_eq!(b"\r hello world\n ".trim_ascii_end(), b"\r hello world");
assert_eq!(b"  ".trim_ascii_end(), b"");
assert_eq!(b"".trim_ascii_end(), b"");

source [https://doc.rust-lang.org/1.67.0/src/core/slice/ascii.rs.html#156]

PUB FN TRIM_ASCII(&SELF) -> &[U8 [https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]] Ⓘ

🔬This is a nightly-only experimental API. (byte_slice_trim_ascii)

Returns a byte slice with leading and trailing ASCII whitespace bytes removed.

‘Whitespace’ refers to the definition used by u8::is_ascii_whitespace.

EXAMPLES

#![feature(byte_slice_trim_ascii)]

assert_eq!(b"\r hello world\n ".trim_ascii(), b"hello world");
assert_eq!(b"  ".trim_ascii(), b"");
assert_eq!(b"".trim_ascii(), b"");

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#4202]

PUB FN FLATTEN(&SELF) -> &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html] Ⓘ

🔬This is a nightly-only experimental API. (slice_flatten)

Takes a &[[T; N]], and flattens it to a &[T].

PANICS

This panics if the length of the resulting slice would overflow a usize.

This is only possible when flattening a slice of arrays of zero-sized types, and thus tends to be irrelevant in practice. If
size_of::<T>() > 0, this will never panic.

EXAMPLES

#![feature(slice_flatten)]

assert_eq!([[1, 2, 3], [4, 5, 6]].flatten(), &[1, 2, 3, 4, 5, 6]);

assert_eq!(
    [[1, 2, 3], [4, 5, 6]].flatten(),
    [[1, 2], [3, 4], [5, 6]].flatten(),
);

let slice_of_empty_arrays: &[[i32; 0]] = &[[], [], [], [], []];
assert!(slice_of_empty_arrays.flatten().is_empty());

let empty_slice_of_arrays: &[[u32; 10]] = &[];
assert!(empty_slice_of_arrays.flatten().is_empty());

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#130]

PUB FN LEN(&SELF) -> USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]

Returns the number of elements in the slice.

EXAMPLES

let a = [1, 2, 3];
assert_eq!(a.len(), 3);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#146]

PUB FN IS_EMPTY(&SELF) -> BOOL [https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]

Returns true if the slice has a length of 0.

EXAMPLES

let a = [1, 2, 3];
assert!(!a.is_empty());

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#165]

PUB FN FIRST(&SELF) -> OPTION [https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T>

Returns the first element of the slice, or None if it is empty.

EXAMPLES

let v = [10, 40, 30];
assert_eq!(Some(&10), v.first());

let w: &[i32] = &[];
assert_eq!(None, w.first());

1.5.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#205]

PUB FN SPLIT_FIRST(&SELF) -> OPTION [https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<(&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T, &[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])>

Returns the first and all the rest of the elements of the slice, or None if it is empty.

EXAMPLES

let x = &[0, 1, 2];

if let Some((first, elements)) = x.split_first() {
    assert_eq!(first, &0);
    assert_eq!(elements, &[1, 2]);
}

1.5.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#247]

PUB FN SPLIT_LAST(&SELF) -> OPTION [https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<(&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T, &[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])>

Returns the last and all the rest of the elements of the slice, or None if it is empty.

EXAMPLES

let x = &[0, 1, 2];

if let Some((last, elements)) = x.split_last() {
    assert_eq!(last, &2);
    assert_eq!(elements, &[0, 1]);
}

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#288]

PUB FN LAST(&SELF) -> OPTION [https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T>

Returns the last element of the slice, or None if it is empty.

EXAMPLES

let v = [10, 40, 30];
assert_eq!(Some(&30), v.last());

let w: &[i32] = &[];
assert_eq!(None, w.last());

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#333-335]

PUB FN GET<I>(&SELF, INDEX: I) -> OPTION [https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&<I AS SLICEINDEX
[https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html]<[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>>::OUTPUT
[https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html#associatedtype.Output]>WHERE
    I: SLICEINDEX [https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html]<[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>,

Returns a reference to an element or subslice depending on the type of index.

 * If given a position, returns a reference to the element at that position or None if out of bounds.
 * If given a range, returns the subslice corresponding to that range, or None if out of bounds.

EXAMPLES

let v = [10, 40, 30];
assert_eq!(Some(&40), v.get(1));
assert_eq!(Some(&[10, 40][..]), v.get(0..2));
assert_eq!(None, v.get(3));
assert_eq!(None, v.get(0..4));

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#392-394]

PUB UNSAFE FN GET_UNCHECKED<I>(
    &SELF,
    INDEX: I
) -> &<I AS SLICEINDEX [https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html]<[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>>::OUTPUT
[https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html#associatedtype.Output]WHERE
    I: SLICEINDEX [https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html]<[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>,

Returns a reference to an element or subslice, without doing bounds checking.

For a safe alternative see get [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.get].

SAFETY

Calling this method with an out-of-bounds index is undefined behavior
[https://doc.rust-lang.org/reference/behavior-considered-undefined.html] even if the resulting reference is not used.

EXAMPLES

let x = &[1, 2, 4];

unsafe {
    assert_eq!(x.get_unchecked(1), &2);
}

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#470]

PUB FN AS_PTR(&SELF) -> *CONST T [https://doc.rust-lang.org/1.67.0/std/primitive.pointer.html]

Returns a raw pointer to the slice’s buffer.

The caller must ensure that the slice outlives the pointer this function returns, or else it will end up pointing to garbage.

The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an
UnsafeCell) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use as_mut_ptr
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.as_mut_ptr].

Modifying the container referenced by this slice may cause its buffer to be reallocated, which would also make any pointers to it
invalid.

EXAMPLES

let x = &[1, 2, 4];
let x_ptr = x.as_ptr();

unsafe {
    for i in 0..x.len() {
        assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));
    }
}

1.48.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#536]

PUB FN AS_PTR_RANGE(&SELF) -> RANGE [https://doc.rust-lang.org/1.67.0/core/ops/range/struct.Range.html]<*CONST T
[https://doc.rust-lang.org/1.67.0/std/primitive.pointer.html]>

Returns the two raw pointers spanning the slice.

The returned range is half-open, which means that the end pointer points one past the last element of the slice. This way, an
empty slice is represented by two equal pointers, and the difference between the two pointers represents the size of the slice.

See as_ptr [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.as_ptr] for warnings on using these pointers. The end
pointer requires extra caution, as it does not point to a valid element in the slice.

This function is useful for interacting with foreign interfaces which use two pointers to refer to a range of elements in memory,
as is common in C++.

It can also be useful to check if a pointer to an element refers to an element of this slice:

let a = [1, 2, 3];
let x = &a[1] as *const _;
let y = &5 as *const _;

assert!(a.as_ptr_range().contains(&x));
assert!(!a.as_ptr_range().contains(&y));

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#735]

PUB FN ITER(&SELF) -> ITER [https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.Iter.html]<'_, T>

Returns an iterator over the slice.

The iterator yields all items from start to end.

EXAMPLES

let x = &[1, 2, 4];
let mut iterator = x.iter();

assert_eq!(iterator.next(), Some(&1));
assert_eq!(iterator.next(), Some(&2));
assert_eq!(iterator.next(), Some(&4));
assert_eq!(iterator.next(), None);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#786]

PUB FN WINDOWS(&SELF, SIZE: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> WINDOWS
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.Windows.html]<'_, T>

Returns an iterator over all contiguous windows of length size. The windows overlap. If the slice is shorter than size, the
iterator returns no values.

PANICS

Panics if size is 0.

EXAMPLES

let slice = ['r', 'u', 's', 't'];
let mut iter = slice.windows(2);
assert_eq!(iter.next().unwrap(), &['r', 'u']);
assert_eq!(iter.next().unwrap(), &['u', 's']);
assert_eq!(iter.next().unwrap(), &['s', 't']);
assert!(iter.next().is_none());

If the slice is shorter than size:

let slice = ['f', 'o', 'o'];
let mut iter = slice.windows(4);
assert!(iter.next().is_none());

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#820]

PUB FN CHUNKS(&SELF, CHUNK_SIZE: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> CHUNKS
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.Chunks.html]<'_, T>

Returns an iterator over chunk_size elements of the slice at a time, starting at the beginning of the slice.

The chunks are slices and do not overlap. If chunk_size does not divide the length of the slice, then the last chunk will not have
length chunk_size.

See chunks_exact [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks_exact] for a variant of this iterator
that returns chunks of always exactly chunk_size elements, and rchunks
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.rchunks] for the same iterator but starting at the end of the
slice.

PANICS

Panics if chunk_size is 0.

EXAMPLES

let slice = ['l', 'o', 'r', 'e', 'm'];
let mut iter = slice.chunks(2);
assert_eq!(iter.next().unwrap(), &['l', 'o']);
assert_eq!(iter.next().unwrap(), &['r', 'e']);
assert_eq!(iter.next().unwrap(), &['m']);
assert!(iter.next().is_none());

1.31.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#895]

PUB FN CHUNKS_EXACT(&SELF, CHUNK_SIZE: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> CHUNKSEXACT
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.ChunksExact.html]<'_, T>

Returns an iterator over chunk_size elements of the slice at a time, starting at the beginning of the slice.

The chunks are slices and do not overlap. If chunk_size does not divide the length of the slice, then the last up to chunk_size-1
elements will be omitted and can be retrieved from the remainder function of the iterator.

Due to each chunk having exactly chunk_size elements, the compiler can often optimize the resulting code better than in the case
of chunks [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks].

See chunks [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks] for a variant of this iterator that also
returns the remainder as a smaller chunk, and rchunks_exact
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.rchunks_exact] for the same iterator but starting at the end of
the slice.

PANICS

Panics if chunk_size is 0.

EXAMPLES

let slice = ['l', 'o', 'r', 'e', 'm'];
let mut iter = slice.chunks_exact(2);
assert_eq!(iter.next().unwrap(), &['l', 'o']);
assert_eq!(iter.next().unwrap(), &['r', 'e']);
assert!(iter.next().is_none());
assert_eq!(iter.remainder(), &['m']);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#972]

PUB UNSAFE FN AS_CHUNKS_UNCHECKED<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&SELF) -> &[[T; N]
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html]]

🔬This is a nightly-only experimental API. (slice_as_chunks)

Splits the slice into a slice of N-element arrays, assuming that there’s no remainder.

SAFETY

This may only be called when

 * The slice splits exactly into N-element chunks (aka self.len() % N == 0).
 * N != 0.

EXAMPLES

#![feature(slice_as_chunks)]
let slice: &[char] = &['l', 'o', 'r', 'e', 'm', '!'];
let chunks: &[[char; 1]] =
    // SAFETY: 1-element chunks never have remainder
    unsafe { slice.as_chunks_unchecked() };
assert_eq!(chunks, &[['l'], ['o'], ['r'], ['e'], ['m'], ['!']]);
let chunks: &[[char; 3]] =
    // SAFETY: The slice length (6) is a multiple of 3
    unsafe { slice.as_chunks_unchecked() };
assert_eq!(chunks, &[['l', 'o', 'r'], ['e', 'm', '!']]);

// These would be unsound:
// let chunks: &[[_; 5]] = slice.as_chunks_unchecked() // The slice length is not a multiple of 5
// let chunks: &[[_; 0]] = slice.as_chunks_unchecked() // Zero-length chunks are never allowed

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1008]

PUB FN AS_CHUNKS<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&SELF) -> (&[[T; N]
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html]], &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])

🔬This is a nightly-only experimental API. (slice_as_chunks)

Splits the slice into a slice of N-element arrays, starting at the beginning of the slice, and a remainder slice with length
strictly less than N.

PANICS

Panics if N is 0. This check will most probably get changed to a compile time error before this method gets stabilized.

EXAMPLES

#![feature(slice_as_chunks)]
let slice = ['l', 'o', 'r', 'e', 'm'];
let (chunks, remainder) = slice.as_chunks();
assert_eq!(chunks, &[['l', 'o'], ['r', 'e']]);
assert_eq!(remainder, &['m']);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1039]

PUB FN AS_RCHUNKS<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&SELF) -> (&[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &[[T; N]
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html]])

🔬This is a nightly-only experimental API. (slice_as_chunks)

Splits the slice into a slice of N-element arrays, starting at the end of the slice, and a remainder slice with length strictly
less than N.

PANICS

Panics if N is 0. This check will most probably get changed to a compile time error before this method gets stabilized.

EXAMPLES

#![feature(slice_as_chunks)]
let slice = ['l', 'o', 'r', 'e', 'm'];
let (remainder, chunks) = slice.as_rchunks();
assert_eq!(remainder, &['l']);
assert_eq!(chunks, &[['o', 'r'], ['e', 'm']]);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1078]

PUB FN ARRAY_CHUNKS<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&SELF) -> ARRAYCHUNKS
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.ArrayChunks.html]<'_, T, N>

🔬This is a nightly-only experimental API. (array_chunks)

Returns an iterator over N elements of the slice at a time, starting at the beginning of the slice.

The chunks are array references and do not overlap. If N does not divide the length of the slice, then the last up to N-1 elements
will be omitted and can be retrieved from the remainder function of the iterator.

This method is the const generic equivalent of chunks_exact
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks_exact].

PANICS

Panics if N is 0. This check will most probably get changed to a compile time error before this method gets stabilized.

EXAMPLES

#![feature(array_chunks)]
let slice = ['l', 'o', 'r', 'e', 'm'];
let mut iter = slice.array_chunks();
assert_eq!(iter.next().unwrap(), &['l', 'o']);
assert_eq!(iter.next().unwrap(), &['r', 'e']);
assert!(iter.next().is_none());
assert_eq!(iter.remainder(), &['m']);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1267]

PUB FN ARRAY_WINDOWS<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&SELF) -> ARRAYWINDOWS
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.ArrayWindows.html]<'_, T, N>

🔬This is a nightly-only experimental API. (array_windows)

Returns an iterator over overlapping windows of N elements of a slice, starting at the beginning of the slice.

This is the const generic equivalent of windows [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.windows].

If N is greater than the size of the slice, it will return no windows.

PANICS

Panics if N is 0. This check will most probably get changed to a compile time error before this method gets stabilized.

EXAMPLES

#![feature(array_windows)]
let slice = [0, 1, 2, 3];
let mut iter = slice.array_windows();
assert_eq!(iter.next().unwrap(), &[0, 1]);
assert_eq!(iter.next().unwrap(), &[1, 2]);
assert_eq!(iter.next().unwrap(), &[2, 3]);
assert!(iter.next().is_none());

1.31.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1301]

PUB FN RCHUNKS(&SELF, CHUNK_SIZE: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> RCHUNKS
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.RChunks.html]<'_, T>

Returns an iterator over chunk_size elements of the slice at a time, starting at the end of the slice.

The chunks are slices and do not overlap. If chunk_size does not divide the length of the slice, then the last chunk will not have
length chunk_size.

See rchunks_exact [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.rchunks_exact] for a variant of this iterator
that returns chunks of always exactly chunk_size elements, and chunks
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks] for the same iterator but starting at the beginning of
the slice.

PANICS

Panics if chunk_size is 0.

EXAMPLES

let slice = ['l', 'o', 'r', 'e', 'm'];
let mut iter = slice.rchunks(2);
assert_eq!(iter.next().unwrap(), &['e', 'm']);
assert_eq!(iter.next().unwrap(), &['o', 'r']);
assert_eq!(iter.next().unwrap(), &['l']);
assert!(iter.next().is_none());

1.31.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1378]

PUB FN RCHUNKS_EXACT(&SELF, CHUNK_SIZE: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> RCHUNKSEXACT
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.RChunksExact.html]<'_, T>

Returns an iterator over chunk_size elements of the slice at a time, starting at the end of the slice.

The chunks are slices and do not overlap. If chunk_size does not divide the length of the slice, then the last up to chunk_size-1
elements will be omitted and can be retrieved from the remainder function of the iterator.

Due to each chunk having exactly chunk_size elements, the compiler can often optimize the resulting code better than in the case
of rchunks [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.rchunks].

See rchunks [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.rchunks] for a variant of this iterator that also
returns the remainder as a smaller chunk, and chunks_exact
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.chunks_exact] for the same iterator but starting at the
beginning of the slice.

PANICS

Panics if chunk_size is 0.

EXAMPLES

let slice = ['l', 'o', 'r', 'e', 'm'];
let mut iter = slice.rchunks_exact(2);
assert_eq!(iter.next().unwrap(), &['e', 'm']);
assert_eq!(iter.next().unwrap(), &['o', 'r']);
assert!(iter.next().is_none());
assert_eq!(iter.remainder(), &['l']);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1464-1466]

PUB FN GROUP_BY<F>(&SELF, PRED: F) -> GROUPBY [https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.GroupBy.html]<'_, T,
F>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T, &
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

🔬This is a nightly-only experimental API. (slice_group_by)

Returns an iterator over the slice producing non-overlapping runs of elements using the predicate to separate them.

The predicate is called on two elements following themselves, it means the predicate is called on slice[0] and slice[1] then on
slice[1] and slice[2] and so on.

EXAMPLES

#![feature(slice_group_by)]

let slice = &[1, 1, 1, 3, 3, 2, 2, 2];

let mut iter = slice.group_by(|a, b| a == b);

assert_eq!(iter.next(), Some(&[1, 1, 1][..]));
assert_eq!(iter.next(), Some(&[3, 3][..]));
assert_eq!(iter.next(), Some(&[2, 2, 2][..]));
assert_eq!(iter.next(), None);

This method can be used to extract the sorted subslices:

#![feature(slice_group_by)]

let slice = &[1, 1, 2, 3, 2, 3, 2, 3, 4];

let mut iter = slice.group_by(|a, b| a <= b);

assert_eq!(iter.next(), Some(&[1, 1, 2, 3][..]));
assert_eq!(iter.next(), Some(&[2, 3][..]));
assert_eq!(iter.next(), Some(&[2, 3, 4][..]));
assert_eq!(iter.next(), None);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1554]

PUB FN SPLIT_AT(&SELF, MID: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> (&[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])

Divides one slice into two at an index.

The first will contain all indices from [0, mid) (excluding the index mid itself) and the second will contain all indices from
[mid, len) (excluding the index len itself).

PANICS

Panics if mid > len.

EXAMPLES

let v = [1, 2, 3, 4, 5, 6];

{
   let (left, right) = v.split_at(0);
   assert_eq!(left, []);
   assert_eq!(right, [1, 2, 3, 4, 5, 6]);
}

{
    let (left, right) = v.split_at(2);
    assert_eq!(left, [1, 2]);
    assert_eq!(right, [3, 4, 5, 6]);
}

{
    let (left, right) = v.split_at(6);
    assert_eq!(left, [1, 2, 3, 4, 5, 6]);
    assert_eq!(right, []);
}

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1640]

PUB UNSAFE FN SPLIT_AT_UNCHECKED(&SELF, MID: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> (&[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])

🔬This is a nightly-only experimental API. (slice_split_at_unchecked)

Divides one slice into two at an index, without doing bounds checking.

The first will contain all indices from [0, mid) (excluding the index mid itself) and the second will contain all indices from
[mid, len) (excluding the index len itself).

For a safe alternative see split_at [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.split_at].

SAFETY

Calling this method with an out-of-bounds index is undefined behavior
[https://doc.rust-lang.org/reference/behavior-considered-undefined.html] even if the resulting reference is not used. The caller
has to ensure that 0 <= mid <= self.len().

EXAMPLES

#![feature(slice_split_at_unchecked)]

let v = [1, 2, 3, 4, 5, 6];

unsafe {
   let (left, right) = v.split_at_unchecked(0);
   assert_eq!(left, []);
   assert_eq!(right, [1, 2, 3, 4, 5, 6]);
}

unsafe {
    let (left, right) = v.split_at_unchecked(2);
    assert_eq!(left, [1, 2]);
    assert_eq!(right, [3, 4, 5, 6]);
}

unsafe {
    let (left, right) = v.split_at_unchecked(6);
    assert_eq!(left, [1, 2, 3, 4, 5, 6]);
    assert_eq!(right, []);
}

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1745]

PUB FN SPLIT_ARRAY_REF<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&SELF) -> (&[T; N]
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html], &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])

🔬This is a nightly-only experimental API. (split_array)

Divides one slice into an array and a remainder slice at an index.

The array will contain all indices from [0, N) (excluding the index N itself) and the slice will contain all indices from [N, len)
(excluding the index len itself).

PANICS

Panics if N > len.

EXAMPLES

#![feature(split_array)]

let v = &[1, 2, 3, 4, 5, 6][..];

{
   let (left, right) = v.split_array_ref::<0>();
   assert_eq!(left, &[]);
   assert_eq!(right, [1, 2, 3, 4, 5, 6]);
}

{
    let (left, right) = v.split_array_ref::<2>();
    assert_eq!(left, &[1, 2]);
    assert_eq!(right, [3, 4, 5, 6]);
}

{
    let (left, right) = v.split_array_ref::<6>();
    assert_eq!(left, &[1, 2, 3, 4, 5, 6]);
    assert_eq!(right, []);
}

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1823]

PUB FN RSPLIT_ARRAY_REF<CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&SELF) -> (&[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &[T; N] [https://doc.rust-lang.org/1.67.0/std/primitive.array.html])

🔬This is a nightly-only experimental API. (split_array)

Divides one slice into an array and a remainder slice at an index from the end.

The slice will contain all indices from [0, len - N) (excluding the index len - N itself) and the array will contain all indices
from [len - N, len) (excluding the index len itself).

PANICS

Panics if N > len.

EXAMPLES

#![feature(split_array)]

let v = &[1, 2, 3, 4, 5, 6][..];

{
   let (left, right) = v.rsplit_array_ref::<0>();
   assert_eq!(left, [1, 2, 3, 4, 5, 6]);
   assert_eq!(right, &[]);
}

{
    let (left, right) = v.rsplit_array_ref::<2>();
    assert_eq!(left, [1, 2, 3, 4]);
    assert_eq!(right, &[5, 6]);
}

{
    let (left, right) = v.rsplit_array_ref::<6>();
    assert_eq!(left, []);
    assert_eq!(right, &[1, 2, 3, 4, 5, 6]);
}

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1906-1908]

PUB FN SPLIT<F>(&SELF, PRED: F) -> SPLIT [https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.Split.html]<'_, T, F>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

Returns an iterator over subslices separated by elements that match pred. The matched element is not contained in the subslices.

EXAMPLES

let slice = [10, 40, 33, 20];
let mut iter = slice.split(|num| num % 3 == 0);

assert_eq!(iter.next().unwrap(), &[10, 40]);
assert_eq!(iter.next().unwrap(), &[20]);
assert!(iter.next().is_none());

If the first element is matched, an empty slice will be the first item returned by the iterator. Similarly, if the last element in
the slice is matched, an empty slice will be the last item returned by the iterator:

let slice = [10, 40, 33];
let mut iter = slice.split(|num| num % 3 == 0);

assert_eq!(iter.next().unwrap(), &[10, 40]);
assert_eq!(iter.next().unwrap(), &[]);
assert!(iter.next().is_none());

If two matched elements are directly adjacent, an empty slice will be present between them:

let slice = [10, 6, 33, 20];
let mut iter = slice.split(|num| num % 3 == 0);

assert_eq!(iter.next().unwrap(), &[10]);
assert_eq!(iter.next().unwrap(), &[]);
assert_eq!(iter.next().unwrap(), &[20]);
assert!(iter.next().is_none());

1.51.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#1964-1966]

PUB FN SPLIT_INCLUSIVE<F>(&SELF, PRED: F) -> SPLITINCLUSIVE
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.SplitInclusive.html]<'_, T, F>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

Returns an iterator over subslices separated by elements that match pred. The matched element is contained in the end of the
previous subslice as a terminator.

EXAMPLES

let slice = [10, 40, 33, 20];
let mut iter = slice.split_inclusive(|num| num % 3 == 0);

assert_eq!(iter.next().unwrap(), &[10, 40, 33]);
assert_eq!(iter.next().unwrap(), &[20]);
assert!(iter.next().is_none());

If the last element of the slice is matched, that element will be considered the terminator of the preceding slice. That slice
will be the last item returned by the iterator.

let slice = [3, 10, 40, 33];
let mut iter = slice.split_inclusive(|num| num % 3 == 0);

assert_eq!(iter.next().unwrap(), &[3]);
assert_eq!(iter.next().unwrap(), &[10, 40, 33]);
assert!(iter.next().is_none());

1.27.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2024-2026]

PUB FN RSPLIT<F>(&SELF, PRED: F) -> RSPLIT [https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.RSplit.html]<'_, T, F>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

Returns an iterator over subslices separated by elements that match pred, starting at the end of the slice and working backwards.
The matched element is not contained in the subslices.

EXAMPLES

let slice = [11, 22, 33, 0, 44, 55];
let mut iter = slice.rsplit(|num| *num == 0);

assert_eq!(iter.next().unwrap(), &[44, 55]);
assert_eq!(iter.next().unwrap(), &[11, 22, 33]);
assert_eq!(iter.next(), None);

As with split(), if the first or last element is matched, an empty slice will be the first (or last) item returned by the
iterator.

let v = &[0, 1, 1, 2, 3, 5, 8];
let mut it = v.rsplit(|n| *n % 2 == 0);
assert_eq!(it.next().unwrap(), &[]);
assert_eq!(it.next().unwrap(), &[3, 5]);
assert_eq!(it.next().unwrap(), &[1, 1]);
assert_eq!(it.next().unwrap(), &[]);
assert_eq!(it.next(), None);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2078-2080]

PUB FN SPLITN<F>(&SELF, N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html], PRED: F) -> SPLITN
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.SplitN.html]<'_, T, F>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

Returns an iterator over subslices separated by elements that match pred, limited to returning at most n items. The matched
element is not contained in the subslices.

The last element returned, if any, will contain the remainder of the slice.

EXAMPLES

Print the slice split once by numbers divisible by 3 (i.e., [10, 40], [20, 60, 50]):

let v = [10, 40, 30, 20, 60, 50];

for group in v.splitn(2, |num| *num % 3 == 0) {
    println!("{group:?}");
}

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2133-2135]

PUB FN RSPLITN<F>(&SELF, N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html], PRED: F) -> RSPLITN
[https://doc.rust-lang.org/1.67.0/core/slice/iter/struct.RSplitN.html]<'_, T, F>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

Returns an iterator over subslices separated by elements that match pred limited to returning at most n items. This starts at the
end of the slice and works backwards. The matched element is not contained in the subslices.

The last element returned, if any, will contain the remainder of the slice.

EXAMPLES

Print the slice split once, starting from the end, by numbers divisible by 3 (i.e., [50], [10, 40, 30, 20]):

let v = [10, 40, 30, 20, 60, 50];

for group in v.rsplitn(2, |num| *num % 3 == 0) {
    println!("{group:?}");
}

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2195-2197]

PUB FN CONTAINS(&SELF, X: & [https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]WHERE
    T: PARTIALEQ [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialEq.html]<T>,

Returns true if the slice contains an element with the given value.

This operation is O(n).

Note that if you have a sorted slice, binary_search
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search] may be faster.

EXAMPLES

let v = [10, 40, 30];
assert!(v.contains(&30));
assert!(!v.contains(&50));

If you do not have a &T, but some other value that you can compare with one (for example, String implements PartialEq<str>), you
can use iter().any:

let v = [String::from("hello"), String::from("world")]; // slice of `String`
assert!(v.iter().any(|e| e == "hello")); // search with `&str`
assert!(!v.iter().any(|e| e == "hi"));

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2224-2226]

PUB FN STARTS_WITH(&SELF, NEEDLE: &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]WHERE
    T: PARTIALEQ [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialEq.html]<T>,

Returns true if needle is a prefix of the slice.

EXAMPLES

let v = [10, 40, 30];
assert!(v.starts_with(&[10]));
assert!(v.starts_with(&[10, 40]));
assert!(!v.starts_with(&[50]));
assert!(!v.starts_with(&[10, 50]));

Always returns true if needle is an empty slice:

let v = &[10, 40, 30];
assert!(v.starts_with(&[]));
let v: &[u8] = &[];
assert!(v.starts_with(&[]));

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2254-2256]

PUB FN ENDS_WITH(&SELF, NEEDLE: &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]WHERE
    T: PARTIALEQ [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialEq.html]<T>,

Returns true if needle is a suffix of the slice.

EXAMPLES

let v = [10, 40, 30];
assert!(v.ends_with(&[30]));
assert!(v.ends_with(&[40, 30]));
assert!(!v.ends_with(&[50]));
assert!(!v.ends_with(&[50, 30]));

Always returns true if needle is an empty slice:

let v = &[10, 40, 30];
assert!(v.ends_with(&[]));
let v: &[u8] = &[];
assert!(v.ends_with(&[]));

1.51.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2284-2286]

PUB FN STRIP_PREFIX<P>(&SELF, PREFIX: & [https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]P) -> OPTION
[https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>WHERE
    P: SLICEPATTERN [https://doc.rust-lang.org/1.67.0/core/slice/trait.SlicePattern.html]<ITEM = T> + ?SIZED
[https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],
    T: PARTIALEQ [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialEq.html]<T>,

Returns a subslice with the prefix removed.

If the slice starts with prefix, returns the subslice after the prefix, wrapped in Some. If prefix is empty, simply returns the
original slice.

If the slice does not start with prefix, returns None.

EXAMPLES

let v = &[10, 40, 30];
assert_eq!(v.strip_prefix(&[10]), Some(&[40, 30][..]));
assert_eq!(v.strip_prefix(&[10, 40]), Some(&[30][..]));
assert_eq!(v.strip_prefix(&[50]), None);
assert_eq!(v.strip_prefix(&[10, 50]), None);

let prefix : &str = "he";
assert_eq!(b"hello".strip_prefix(prefix.as_bytes()),
           Some(b"llo".as_ref()));

1.51.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2318-2320]

PUB FN STRIP_SUFFIX<P>(&SELF, SUFFIX: & [https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]P) -> OPTION
[https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<&[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]>WHERE
    P: SLICEPATTERN [https://doc.rust-lang.org/1.67.0/core/slice/trait.SlicePattern.html]<ITEM = T> + ?SIZED
[https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],
    T: PARTIALEQ [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialEq.html]<T>,

Returns a subslice with the suffix removed.

If the slice ends with suffix, returns the subslice before the suffix, wrapped in Some. If suffix is empty, simply returns the
original slice.

If the slice does not end with suffix, returns None.

EXAMPLES

let v = &[10, 40, 30];
assert_eq!(v.strip_suffix(&[30]), Some(&[10, 40][..]));
assert_eq!(v.strip_suffix(&[40, 30]), Some(&[10][..]));
assert_eq!(v.strip_suffix(&[50]), None);
assert_eq!(v.strip_suffix(&[50, 30]), None);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2402-2404]

PUB FN BINARY_SEARCH(&SELF, X: & [https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> RESULT
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html],
USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>WHERE
    T: ORD [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html],

Binary searches this slice for a given element. This behaves similarly to contains
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.contains] if this slice is sorted.

If the value is found then Result::Ok [https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html#variant.Ok] is returned,
containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. The
index is chosen deterministically, but is subject to change in future versions of Rust. If the value is not found then Result::Err
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html#variant.Err] is returned, containing the index where a matching
element could be inserted while maintaining sorted order.

See also binary_search_by [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search_by],
binary_search_by_key [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search_by_key], and partition_point
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.partition_point].

EXAMPLES

Looks up a series of four elements. The first is found, with a uniquely determined position; the second and third are not found;
the fourth could match any position in [1, 4].

let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];

assert_eq!(s.binary_search(&13),  Ok(9));
assert_eq!(s.binary_search(&4),   Err(7));
assert_eq!(s.binary_search(&100), Err(13));
let r = s.binary_search(&1);
assert!(match r { Ok(1..=4) => true, _ => false, });

If you want to find that whole range of matching items, rather than an arbitrary matching one, that can be done using
partition_point [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.partition_point]:

let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];

let low = s.partition_point(|x| x < &1);
assert_eq!(low, 1);
let high = s.partition_point(|x| x <= &1);
assert_eq!(high, 5);
let r = s.binary_search(&1);
assert!((low..high).contains(&r.unwrap()));

assert!(s[..low].iter().all(|&x| x < 1));
assert!(s[low..high].iter().all(|&x| x == 1));
assert!(s[high..].iter().all(|&x| x > 1));

// For something not found, the "range" of equal items is empty
assert_eq!(s.partition_point(|x| x < &11), 9);
assert_eq!(s.partition_point(|x| x <= &11), 9);
assert_eq!(s.binary_search(&11), Err(9));

If you want to insert an item to a sorted vector, while maintaining sort order, consider using partition_point
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.partition_point]:

let mut s = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];
let num = 42;
let idx = s.partition_point(|&x| x < num);
// The above is equivalent to `let idx = s.binary_search(&num).unwrap_or_else(|x| x);`
s.insert(idx, num);
assert_eq!(s, [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2453-2455]

PUB FN BINARY_SEARCH_BY<'A, F>(&'A SELF, F: F) -> RESULT [https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<USIZE
[https://doc.rust-lang.org/1.67.0/std/primitive.usize.html], USIZE
[https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&'A
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> ORDERING
[https://doc.rust-lang.org/1.67.0/core/cmp/enum.Ordering.html],

Binary searches this slice with a comparator function. This behaves similarly to contains
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.contains] if this slice is sorted.

The comparator function should implement an order consistent with the sort order of the underlying slice, returning an order code
that indicates whether its argument is Less, Equal or Greater the desired target.

If the value is found then Result::Ok [https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html#variant.Ok] is returned,
containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. The
index is chosen deterministically, but is subject to change in future versions of Rust. If the value is not found then Result::Err
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html#variant.Err] is returned, containing the index where a matching
element could be inserted while maintaining sorted order.

See also binary_search [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search], binary_search_by_key
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search_by_key], and partition_point
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.partition_point].

EXAMPLES

Looks up a series of four elements. The first is found, with a uniquely determined position; the second and third are not found;
the fourth could match any position in [1, 4].

let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];

let seek = 13;
assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));
let seek = 4;
assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));
let seek = 100;
assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));
let seek = 1;
let r = s.binary_search_by(|probe| probe.cmp(&seek));
assert!(match r { Ok(1..=4) => true, _ => false, });

1.10.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#2542-2545]

PUB FN BINARY_SEARCH_BY_KEY<'A, B, F>(
    &'A SELF,
    B: & [https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]B,
    F: F
) -> RESULT [https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<USIZE
[https://doc.rust-lang.org/1.67.0/std/primitive.usize.html], USIZE
[https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&'A
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> B,
    B: ORD [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html],

Binary searches this slice with a key extraction function. This behaves similarly to contains
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.contains] if this slice is sorted.

Assumes that the slice is sorted by the key, for instance with sort_by_key
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.sort_by_key] using the same key extraction function.

If the value is found then Result::Ok [https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html#variant.Ok] is returned,
containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. The
index is chosen deterministically, but is subject to change in future versions of Rust. If the value is not found then Result::Err
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html#variant.Err] is returned, containing the index where a matching
element could be inserted while maintaining sorted order.

See also binary_search [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search], binary_search_by
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search_by], and partition_point
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.partition_point].

EXAMPLES

Looks up a series of four elements in a slice of pairs sorted by their second elements. The first is found, with a uniquely
determined position; the second and third are not found; the fourth could match any position in [1, 4].

let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),
         (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),
         (1, 21), (2, 34), (4, 55)];

assert_eq!(s.binary_search_by_key(&13, |&(a, b)| b),  Ok(9));
assert_eq!(s.binary_search_by_key(&4, |&(a, b)| b),   Err(7));
assert_eq!(s.binary_search_by_key(&100, |&(a, b)| b), Err(13));
let r = s.binary_search_by_key(&1, |&(a, b)| b);
assert!(match r { Ok(1..=4) => true, _ => false, });

1.30.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3500]

PUB UNSAFE FN ALIGN_TO<U>(&SELF) -> (&[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &[U]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])

Transmute the slice to a slice of another type, ensuring alignment of the types is maintained.

This method splits the slice into three distinct slices: prefix, correctly aligned middle slice of a new type, and the suffix
slice. How exactly the slice is split up is not specified; the middle part may be smaller than necessary. However, if this fails
to return a maximal middle part, that is because code is running in a context where performance does not matter, such as a
sanitizer attempting to find alignment bugs. Regular code running in a default (debug or release) execution will return a maximal
middle part.

This method has no purpose when either input element T or output element U are zero-sized and will return the original slice
without splitting anything.

SAFETY

This method is essentially a transmute with respect to the elements in the returned middle slice, so all the usual caveats
pertaining to transmute::<T, U> also apply here.

EXAMPLES

Basic usage:

unsafe {
    let bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];
    let (prefix, shorts, suffix) = bytes.align_to::<u16>();
    // less_efficient_algorithm_for_bytes(prefix);
    // more_efficient_algorithm_for_aligned_shorts(shorts);
    // less_efficient_algorithm_for_bytes(suffix);
}

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3657-3661]

PUB FN AS_SIMD<CONST LANES: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]>(&SELF) -> (&[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], &[SIMD
[https://doc.rust-lang.org/1.67.0/core/core_simd/vector/struct.Simd.html]<T, LANES>], &[T]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html])WHERE
    SIMD [https://doc.rust-lang.org/1.67.0/core/core_simd/vector/struct.Simd.html]<T, LANES>: ASREF
[https://doc.rust-lang.org/1.67.0/core/convert/trait.AsRef.html]<[T; LANES]
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html]>,
    T: SIMDELEMENT [https://doc.rust-lang.org/1.67.0/core/core_simd/vector/trait.SimdElement.html],
    LANECOUNT [https://doc.rust-lang.org/1.67.0/core/core_simd/lane_count/struct.LaneCount.html]<LANES>: SUPPORTEDLANECOUNT
[https://doc.rust-lang.org/1.67.0/core/core_simd/lane_count/trait.SupportedLaneCount.html],

🔬This is a nightly-only experimental API. (portable_simd)

Split a slice into a prefix, a middle of aligned SIMD types, and a suffix.

This is a safe wrapper around slice::align_to [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.align_to], so has
the same weak postconditions as that method. You’re only assured that self.len() == prefix.len() + middle.len() * LANES +
suffix.len().

Notably, all of the following are possible:

 * prefix.len() >= LANES.
 * middle.is_empty() despite self.len() >= 3 * LANES.
 * suffix.len() >= LANES.

That said, this is a safe method, so if you’re only writing safe code, then this can at most cause incorrect logic, not
unsoundness.

PANICS

This will panic if the size of the SIMD type is different from LANES times that of the scalar.

At the time of writing, the trait restrictions on Simd<T, LANES> keeps that from ever happening, as only power-of-two numbers of
lanes are supported. It’s possible that, in the future, those restrictions might be lifted in a way that would make it possible to
see panics from this method for something like LANES == 3.

EXAMPLES

#![feature(portable_simd)]
use core::simd::SimdFloat;

let short = &[1, 2, 3];
let (prefix, middle, suffix) = short.as_simd::<4>();
assert_eq!(middle, []); // Not enough elements for anything in the middle

// They might be split in any possible way between prefix and suffix
let it = prefix.iter().chain(suffix).copied();
assert_eq!(it.collect::<Vec<_>>(), vec![1, 2, 3]);

fn basic_simd_sum(x: &[f32]) -> f32 {
    use std::ops::Add;
    use std::simd::f32x4;
    let (prefix, middle, suffix) = x.as_simd();
    let sums = f32x4::from_array([
        prefix.iter().copied().sum(),
        0.0,
        0.0,
        suffix.iter().copied().sum(),
    ]);
    let sums = middle.iter().copied().fold(sums, f32x4::add);
    sums.reduce_sum()
}

let numbers: Vec<f32> = (1..101).map(|x| x as _).collect();
assert_eq!(basic_simd_sum(&numbers[1..99]), 4949.0);

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3742-3744]

PUB FN IS_SORTED(&SELF) -> BOOL [https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]WHERE
    T: PARTIALORD [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialOrd.html]<T>,

🔬This is a nightly-only experimental API. (is_sorted)

Checks if the elements of this slice are sorted.

That is, for each element a and its following element b, a <= b must hold. If the slice yields exactly zero or one element, true
is returned.

Note that if Self::Item is only PartialOrd, but not Ord, the above definition implies that this function returns false if any two
consecutive items are not comparable.

EXAMPLES

#![feature(is_sorted)]
let empty: [i32; 0] = [];

assert!([1, 2, 2, 9].is_sorted());
assert!(![1, 3, 2, 4].is_sorted());
assert!([0].is_sorted());
assert!(empty.is_sorted());
assert!(![0.0, 1.0, f32::NAN].is_sorted());

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3758-3760]

PUB FN IS_SORTED_BY<'A, F>(&'A SELF, COMPARE: F) -> BOOL [https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&'A
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T, &'A
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> OPTION
[https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<ORDERING
[https://doc.rust-lang.org/1.67.0/core/cmp/enum.Ordering.html]>,

🔬This is a nightly-only experimental API. (is_sorted)

Checks if the elements of this slice are sorted using the given comparator function.

Instead of using PartialOrd::partial_cmp, this function uses the given compare function to determine the ordering of two elements.
Apart from that, it’s equivalent to is_sorted [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.is_sorted]; see
its documentation for more information.

source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3784-3787]

PUB FN IS_SORTED_BY_KEY<'A, F, K>(&'A SELF, F: F) -> BOOL [https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]WHERE
    F: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&'A
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> K,
    K: PARTIALORD [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialOrd.html]<K>,

🔬This is a nightly-only experimental API. (is_sorted)

Checks if the elements of this slice are sorted using the given key extraction function.

Instead of comparing the slice’s elements directly, this function compares the keys of the elements, as determined by f. Apart
from that, it’s equivalent to is_sorted [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.is_sorted]; see its
documentation for more information.

EXAMPLES

#![feature(is_sorted)]

assert!(["c", "bb", "aaa"].is_sorted_by_key(|s| s.len()));
assert!(![-2i32, -1, 0, 3].is_sorted_by_key(|n| n.abs()));

1.52.0 · source [https://doc.rust-lang.org/1.67.0/src/core/slice/mod.rs.html#3843-3845]

PUB FN PARTITION_POINT<P>(&SELF, PRED: P) -> USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]WHERE
    P: FNMUT [https://doc.rust-lang.org/1.67.0/core/ops/function/trait.FnMut.html](&
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html],

Returns the index of the partition point according to the given predicate (the index of the first element of the second
partition).

The slice is assumed to be partitioned according to the given predicate. This means that all elements for which the predicate
returns true are at the start of the slice and all elements for which the predicate returns false are at the end. For example, [7,
15, 3, 5, 4, 12, 6] is a partitioned under the predicate x % 2 != 0 (all odd numbers are at the start, all even at the end).

If this slice is not partitioned, the returned result is unspecified and meaningless, as this method performs a kind of binary
search.

See also binary_search [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search], binary_search_by
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search_by], and binary_search_by_key
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.binary_search_by_key].

EXAMPLES

let v = [1, 2, 3, 3, 5, 6, 7];
let i = v.partition_point(|&x| x < 5);

assert_eq!(i, 4);
assert!(v[..i].iter().all(|&x| x < 5));
assert!(v[i..].iter().all(|&x| !(x < 5)));

If all elements of the slice match the predicate, including if the slice is empty, then the length of the slice will be returned:

let a = [2, 4, 8];
assert_eq!(a.partition_point(|x| x < &100), a.len());
let a: [i32; 0] = [];
assert_eq!(a.partition_point(|x| x < &100), 0);

If you want to insert an item to a sorted vector, while maintaining sort order:

let mut s = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];
let num = 42;
let idx = s.partition_point(|&x| x < num);
s.insert(idx, num);
assert_eq!(s, [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);

1.23.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#616]

PUB FN TO_ASCII_UPPERCASE(&SELF) -> VEC [https://doc.rust-lang.org/1.67.0/alloc/vec/struct.Vec.html]<U8
[https://doc.rust-lang.org/1.67.0/std/primitive.u8.html], GLOBAL
[https://doc.rust-lang.org/1.67.0/alloc/alloc/struct.Global.html]>

Returns a vector containing a copy of this slice where each byte is mapped to its ASCII upper case equivalent.

ASCII letters ‘a’ to ‘z’ are mapped to ‘A’ to ‘Z’, but non-ASCII letters are unchanged.

To uppercase the value in-place, use make_ascii_uppercase
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.make_ascii_uppercase].

1.23.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#637]

PUB FN TO_ASCII_LOWERCASE(&SELF) -> VEC [https://doc.rust-lang.org/1.67.0/alloc/vec/struct.Vec.html]<U8
[https://doc.rust-lang.org/1.67.0/std/primitive.u8.html], GLOBAL
[https://doc.rust-lang.org/1.67.0/alloc/alloc/struct.Global.html]>

Returns a vector containing a copy of this slice where each byte is mapped to its ASCII lower case equivalent.

ASCII letters ‘A’ to ‘Z’ are mapped to ‘a’ to ‘z’, but non-ASCII letters are unchanged.

To lowercase the value in-place, use make_ascii_lowercase
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html#method.make_ascii_lowercase].

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#407-409]

PUB FN TO_VEC(&SELF) -> VEC [https://doc.rust-lang.org/1.67.0/alloc/vec/struct.Vec.html]<T, GLOBAL
[https://doc.rust-lang.org/1.67.0/alloc/alloc/struct.Global.html]>WHERE
    T: CLONE [https://doc.rust-lang.org/1.67.0/core/clone/trait.Clone.html],

Copies self into a new Vec.

EXAMPLES

let s = [10, 40, 30];
let x = s.to_vec();
// Here, `s` and `x` can be modified independently.

source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#431-433]

PUB FN TO_VEC_IN<A>(&SELF, ALLOC: A) -> VEC [https://doc.rust-lang.org/1.67.0/alloc/vec/struct.Vec.html]<T, A>WHERE
    A: ALLOCATOR [https://doc.rust-lang.org/1.67.0/core/alloc/trait.Allocator.html],
    T: CLONE [https://doc.rust-lang.org/1.67.0/core/clone/trait.Clone.html],

🔬This is a nightly-only experimental API. (allocator_api)

Copies self into a new Vec with an allocator.

EXAMPLES

#![feature(allocator_api)]

use std::alloc::System;

let s = [10, 40, 30];
let x = s.to_vec_in(System);
// Here, `s` and `x` can be modified independently.

1.40.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#484-486]

PUB FN REPEAT(&SELF, N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html]) -> VEC
[https://doc.rust-lang.org/1.67.0/alloc/vec/struct.Vec.html]<T, GLOBAL
[https://doc.rust-lang.org/1.67.0/alloc/alloc/struct.Global.html]>WHERE
    T: COPY [https://doc.rust-lang.org/1.67.0/core/marker/trait.Copy.html],

Creates a vector by copying a slice n times.

PANICS

This function will panic if the capacity would overflow.

EXAMPLES

Basic usage:

assert_eq!([1, 2].repeat(3), vec![1, 2, 1, 2, 1, 2]);

A panic upon overflow:

ⓘ

// this will panic at runtime
b"0123456789abcdef".repeat(usize::MAX);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#552-554]

PUB FN CONCAT<ITEM>(&SELF) -> <[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html] AS CONCAT
[https://doc.rust-lang.org/1.67.0/alloc/slice/trait.Concat.html]<ITEM>>::OUTPUT
[https://doc.rust-lang.org/1.67.0/alloc/slice/trait.Concat.html#associatedtype.Output] ⒾWHERE
    [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]: CONCAT
[https://doc.rust-lang.org/1.67.0/alloc/slice/trait.Concat.html]<ITEM>,
    ITEM: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

Flattens a slice of T into a single value Self::Output.

EXAMPLES

assert_eq!(["hello", "world"].concat(), "helloworld");
assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);

1.3.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#571-573]

PUB FN JOIN<SEPARATOR>(&SELF, SEP: SEPARATOR) -> <[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html] AS JOIN
[https://doc.rust-lang.org/1.67.0/alloc/slice/trait.Join.html]<SEPARATOR>>::OUTPUT
[https://doc.rust-lang.org/1.67.0/alloc/slice/trait.Join.html#associatedtype.Output] ⒾWHERE
    [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]: JOIN
[https://doc.rust-lang.org/1.67.0/alloc/slice/trait.Join.html]<SEPARATOR>,

Flattens a slice of T into a single value Self::Output, placing a given separator between each.

EXAMPLES

assert_eq!(["hello", "world"].join(" "), "hello world");
assert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);
assert_eq!([[1, 2], [3, 4]].join(&[0, 0][..]), [1, 2, 0, 0, 3, 4]);

1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/alloc/slice.rs.html#591-593]

PUB FN CONNECT<SEPARATOR>(
    &SELF,
    SEP: SEPARATOR
) -> <[T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html] AS JOIN
[https://doc.rust-lang.org/1.67.0/alloc/slice/trait.Join.html]<SEPARATOR>>::OUTPUT
[https://doc.rust-lang.org/1.67.0/alloc/slice/trait.Join.html#associatedtype.Output] ⒾWHERE
    [T] [https://doc.rust-lang.org/1.67.0/std/primitive.slice.html]: JOIN
[https://doc.rust-lang.org/1.67.0/alloc/slice/trait.Join.html]<SEPARATOR>,

👎Deprecated since 1.3.0: renamed to join

Flattens a slice of T into a single value Self::Output, placing a given separator between each.

EXAMPLES

assert_eq!(["hello", "world"].connect(" "), "hello world");
assert_eq!([[1, 2], [3, 4]].connect(&0), [1, 2, 0, 3, 4]);


TRAIT IMPLEMENTATIONS§

§


IMPL ASREF [https://doc.rust-lang.org/1.67.0/core/convert/trait.AsRef.html]<[U8
[https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]]> FOR HASH [struct.Sha512.html]

§

FN AS_REF [https://doc.rust-lang.org/1.67.0/core/convert/trait.AsRef.html#tymethod.as_ref](&SELF) -> &[U8
[https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]] Ⓘ

Converts this type into a shared reference of the (usually inferred) input type.
§


IMPL BORROW [https://doc.rust-lang.org/1.67.0/core/borrow/trait.Borrow.html]<[U8
[https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]]> FOR HASH [struct.Sha512.html]

§

FN BORROW [https://doc.rust-lang.org/1.67.0/core/borrow/trait.Borrow.html#tymethod.borrow](&SELF) -> &[U8
[https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]] Ⓘ

Immutably borrows from an owned value. Read more [https://doc.rust-lang.org/1.67.0/core/borrow/trait.Borrow.html#tymethod.borrow]
§


IMPL CLONE [https://doc.rust-lang.org/1.67.0/core/clone/trait.Clone.html] FOR HASH [struct.Sha512.html]

§

FN CLONE [https://doc.rust-lang.org/1.67.0/core/clone/trait.Clone.html#tymethod.clone](&SELF) -> HASH [struct.Sha512.html]

Returns a copy of the value. Read more [https://doc.rust-lang.org/1.67.0/core/clone/trait.Clone.html#tymethod.clone]
1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/clone.rs.html#132-134]§

FN CLONE_FROM [https://doc.rust-lang.org/1.67.0/core/clone/trait.Clone.html#method.clone_from](&MUT SELF, SOURCE: &
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]SELF)

Performs copy-assignment from source. Read more [https://doc.rust-lang.org/1.67.0/core/clone/trait.Clone.html#method.clone_from]
§


IMPL DEBUG [https://doc.rust-lang.org/1.67.0/core/fmt/trait.Debug.html] FOR HASH [struct.Sha512.html]

§

FN FMT [https://doc.rust-lang.org/1.67.0/core/fmt/trait.Debug.html#tymethod.fmt](&SELF, F: &MUT FORMATTER
[https://doc.rust-lang.org/1.67.0/core/fmt/struct.Formatter.html]<'_>) -> RESULT
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<() [https://doc.rust-lang.org/1.67.0/std/primitive.unit.html],
ERROR [https://doc.rust-lang.org/1.67.0/core/fmt/struct.Error.html]>

Formats the value using the given formatter. Read more [https://doc.rust-lang.org/1.67.0/core/fmt/trait.Debug.html#tymethod.fmt]
§


IMPL DEFAULT [https://doc.rust-lang.org/1.67.0/core/default/trait.Default.html] FOR HASH [struct.Sha512.html]

§

FN DEFAULT [https://doc.rust-lang.org/1.67.0/core/default/trait.Default.html#tymethod.default]() -> HASH [struct.Sha512.html]

Returns the “default value” for a type. Read more
[https://doc.rust-lang.org/1.67.0/core/default/trait.Default.html#tymethod.default]
§


IMPL DEREF [https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.Deref.html] FOR HASH [struct.Sha512.html]

§

TYPE TARGET [https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.Deref.html#associatedtype.Target] = [U8
[https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]]

The resulting type after dereferencing.
§

FN DEREF [https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.Deref.html#tymethod.deref](&SELF) -> &<HASH [struct.Sha512.html]
AS DEREF [https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.Deref.html]>::TARGET
[https://doc.rust-lang.org/1.67.0/core/ops/deref/trait.Deref.html#associatedtype.Target]

Dereferences the value.
§


IMPL<'DE> DESERIALIZE [https://docs.rs/serde/1.0.163/serde/de/trait.Deserialize.html]<'DE> FOR HASH [struct.Sha512.html]

§

FN DESERIALIZE [https://docs.rs/serde/1.0.163/serde/de/trait.Deserialize.html#tymethod.deserialize]<D>(D: D) -> RESULT
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<HASH [struct.Sha512.html], <D AS DESERIALIZER
[https://docs.rs/serde/1.0.163/serde/de/trait.Deserializer.html]<'DE>>::ERROR
[https://docs.rs/serde/1.0.163/serde/de/trait.Deserializer.html#associatedtype.Error]>WHERE
    D: DESERIALIZER [https://docs.rs/serde/1.0.163/serde/de/trait.Deserializer.html]<'DE>,

Deserialize this value from the given Serde deserializer. Read more
[https://docs.rs/serde/1.0.163/serde/de/trait.Deserialize.html#tymethod.deserialize]
§


IMPL DISPLAY [https://doc.rust-lang.org/1.67.0/core/fmt/trait.Display.html] FOR HASH [struct.Sha512.html]

§

FN FMT [https://doc.rust-lang.org/1.67.0/core/fmt/trait.Display.html#tymethod.fmt](&SELF, F: &MUT FORMATTER
[https://doc.rust-lang.org/1.67.0/core/fmt/struct.Formatter.html]<'_>) -> RESULT
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<() [https://doc.rust-lang.org/1.67.0/std/primitive.unit.html],
ERROR [https://doc.rust-lang.org/1.67.0/core/fmt/struct.Error.html]>

Formats the value using the given formatter. Read more [https://doc.rust-lang.org/1.67.0/core/fmt/trait.Display.html#tymethod.fmt]
§


IMPL FROMSTR [https://doc.rust-lang.org/1.67.0/core/str/traits/trait.FromStr.html] FOR HASH [struct.Sha512.html]

§

TYPE ERR [https://doc.rust-lang.org/1.67.0/core/str/traits/trait.FromStr.html#associatedtype.Err] = ERROR

The associated error which can be returned from parsing.
§

FN FROM_STR [https://doc.rust-lang.org/1.67.0/core/str/traits/trait.FromStr.html#tymethod.from_str](S: &STR
[https://doc.rust-lang.org/1.67.0/std/primitive.str.html]) -> RESULT
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<HASH [struct.Sha512.html], <HASH [struct.Sha512.html] AS FROMSTR
[https://doc.rust-lang.org/1.67.0/core/str/traits/trait.FromStr.html]>::ERR
[https://doc.rust-lang.org/1.67.0/core/str/traits/trait.FromStr.html#associatedtype.Err]>

Parses a string s to return a value of this type. Read more
[https://doc.rust-lang.org/1.67.0/core/str/traits/trait.FromStr.html#tymethod.from_str]
§


IMPL HASH [../trait.BitcoinHash.html] FOR HASH [struct.Sha512.html]

§

TYPE ENGINE [../trait.BitcoinHash.html#associatedtype.Engine] = HASHENGINE

A hashing engine which bytes can be serialized into. It is expected to implement the io::Write trait, and to never return errors
under any conditions. Read more [../trait.BitcoinHash.html#associatedtype.Engine]
§

TYPE INNER [../trait.BitcoinHash.html#associatedtype.Inner] = [U8 [https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]; 64
[https://doc.rust-lang.org/1.67.0/std/primitive.array.html]]

The byte array that represents the hash internally.
§

FN FROM_ENGINE [../trait.BitcoinHash.html#tymethod.from_engine](E: HASHENGINE) -> HASH [struct.Sha512.html]

Produces a hash from the current state of a given engine.
§

CONST LEN [../trait.BitcoinHash.html#associatedconstant.LEN]: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html] =
64USIZE

Length of the hash, in bytes.
§

FN FROM_SLICE [../trait.BitcoinHash.html#tymethod.from_slice](SL: &[U8 [https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]])
-> RESULT [https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<HASH [struct.Sha512.html], ERROR>

Copies a byte slice into a hash object.
§

FN INTO_INNER [../trait.BitcoinHash.html#tymethod.into_inner](SELF) -> <HASH [struct.Sha512.html] AS HASH
[../trait.BitcoinHash.html]>::INNER [../trait.BitcoinHash.html#associatedtype.Inner]

Unwraps the hash and returns the underlying byte array.
§

FN AS_INNER [../trait.BitcoinHash.html#tymethod.as_inner](&SELF) -> &<HASH [struct.Sha512.html] AS HASH
[../trait.BitcoinHash.html]>::INNER [../trait.BitcoinHash.html#associatedtype.Inner]

Unwraps the hash and returns a reference to the underlying byte array.
§

FN FROM_INNER [../trait.BitcoinHash.html#tymethod.from_inner](INNER: <HASH [struct.Sha512.html] AS HASH
[../trait.BitcoinHash.html]>::INNER [../trait.BitcoinHash.html#associatedtype.Inner]) -> HASH [struct.Sha512.html]

Constructs a hash from the underlying byte array.
§

FN ALL_ZEROS [../trait.BitcoinHash.html#tymethod.all_zeros]() -> HASH [struct.Sha512.html]

Returns an all zero hash. Read more [../trait.BitcoinHash.html#tymethod.all_zeros]
§

FN ENGINE [../trait.BitcoinHash.html#method.engine]() -> SELF::ENGINE [../trait.BitcoinHash.html#associatedtype.Engine]

Constructs a new engine.
§

FN HASH [../trait.BitcoinHash.html#method.hash](DATA: &[U8 [https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]]) -> SELF

Hashes some bytes.
§

CONST DISPLAY_BACKWARD [../trait.BitcoinHash.html#associatedconstant.DISPLAY_BACKWARD]: BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html] = FALSE

Flag indicating whether user-visible serializations of this hash should be backward. For some reason Satoshi decided this should
be true for Sha256dHash, so here we are. Read more [../trait.BitcoinHash.html#associatedconstant.DISPLAY_BACKWARD]
§


IMPL HASH [https://doc.rust-lang.org/1.67.0/core/hash/trait.Hash.html] FOR HASH [struct.Sha512.html]

§

FN HASH [https://doc.rust-lang.org/1.67.0/core/hash/trait.Hash.html#tymethod.hash]<H>(&SELF, STATE: &MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]H)WHERE
    H: HASHER [https://doc.rust-lang.org/1.67.0/core/hash/trait.Hasher.html],

Feeds this value into the given Hasher [https://doc.rust-lang.org/1.67.0/core/hash/trait.Hasher.html]. Read more
[https://doc.rust-lang.org/1.67.0/core/hash/trait.Hash.html#tymethod.hash]
1.3.0 · source [https://doc.rust-lang.org/1.67.0/src/core/hash/mod.rs.html#239-241]§

FN HASH_SLICE [https://doc.rust-lang.org/1.67.0/core/hash/trait.Hash.html#method.hash_slice]<H>(DATA: &[SELF]
[https://doc.rust-lang.org/1.67.0/std/primitive.slice.html], STATE: &MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]H)WHERE
    H: HASHER [https://doc.rust-lang.org/1.67.0/core/hash/trait.Hasher.html],
    SELF: SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

Feeds a slice of this type into the given Hasher [https://doc.rust-lang.org/1.67.0/core/hash/trait.Hasher.html]. Read more
[https://doc.rust-lang.org/1.67.0/core/hash/trait.Hash.html#method.hash_slice]
§


IMPL<I> INDEX [https://doc.rust-lang.org/1.67.0/core/ops/index/trait.Index.html]<I> FOR HASH [struct.Sha512.html]WHERE
    I: SLICEINDEX [https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html]<[U8
[https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]]>,

§

TYPE OUTPUT [https://doc.rust-lang.org/1.67.0/core/ops/index/trait.Index.html#associatedtype.Output] = <I AS SLICEINDEX
[https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html]<[U8
[https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]]>>::OUTPUT
[https://doc.rust-lang.org/1.67.0/core/slice/index/trait.SliceIndex.html#associatedtype.Output]

The returned type after indexing.
§

FN INDEX [https://doc.rust-lang.org/1.67.0/core/ops/index/trait.Index.html#tymethod.index](&SELF, INDEX: I) -> &<HASH
[struct.Sha512.html] AS INDEX [https://doc.rust-lang.org/1.67.0/core/ops/index/trait.Index.html]<I>>::OUTPUT
[https://doc.rust-lang.org/1.67.0/core/ops/index/trait.Index.html#associatedtype.Output]

Performs the indexing (container[index]) operation. Read more
[https://doc.rust-lang.org/1.67.0/core/ops/index/trait.Index.html#tymethod.index]
§


IMPL LOWERHEX [https://doc.rust-lang.org/1.67.0/core/fmt/trait.LowerHex.html] FOR HASH [struct.Sha512.html]

§

FN FMT [https://doc.rust-lang.org/1.67.0/core/fmt/trait.LowerHex.html#tymethod.fmt](&SELF, F: &MUT FORMATTER
[https://doc.rust-lang.org/1.67.0/core/fmt/struct.Formatter.html]<'_>) -> RESULT
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<() [https://doc.rust-lang.org/1.67.0/std/primitive.unit.html],
ERROR [https://doc.rust-lang.org/1.67.0/core/fmt/struct.Error.html]>

Formats the value using the given formatter.
§


IMPL ORD [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html] FOR HASH [struct.Sha512.html]

§

FN CMP [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html#tymethod.cmp](&SELF, OTHER: &HASH [struct.Sha512.html]) ->
ORDERING [https://doc.rust-lang.org/1.67.0/core/cmp/enum.Ordering.html]

This method returns an Ordering [https://doc.rust-lang.org/1.67.0/core/cmp/enum.Ordering.html] between self and other. Read more
[https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html#tymethod.cmp]
1.21.0 · source [https://doc.rust-lang.org/1.67.0/src/core/cmp.rs.html#798-801]§

FN MAX [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html#method.max](SELF, OTHER: SELF) -> SELFWHERE
    SELF: SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

Compares and returns the maximum of two values. Read more [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html#method.max]
1.21.0 · source [https://doc.rust-lang.org/1.67.0/src/core/cmp.rs.html#825-828]§

FN MIN [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html#method.min](SELF, OTHER: SELF) -> SELFWHERE
    SELF: SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

Compares and returns the minimum of two values. Read more [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html#method.min]
1.50.0 · source [https://doc.rust-lang.org/1.67.0/src/core/cmp.rs.html#857-861]§

FN CLAMP [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html#method.clamp](SELF, MIN: SELF, MAX: SELF) -> SELFWHERE
    SELF: SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html] + PARTIALORD
[https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialOrd.html]<SELF>,

Restrict a value to a certain interval. Read more [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Ord.html#method.clamp]
§


IMPL PARTIALEQ [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialEq.html]<HASH [struct.Sha512.html]> FOR HASH
[struct.Sha512.html]

§

FN EQ [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialEq.html#tymethod.eq](&SELF, OTHER: &HASH [struct.Sha512.html]) ->
BOOL [https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]

This method tests for self and other values to be equal, and is used by ==. Read more
[https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialEq.html#tymethod.eq]
1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/cmp.rs.html#229]§

FN NE [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialEq.html#method.ne](&SELF, OTHER: &
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]RHS) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]

This method tests for !=. The default implementation is almost always sufficient, and should not be overridden without very good
reason. Read more [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialEq.html#method.ne]
§


IMPL PARTIALORD [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialOrd.html]<HASH [struct.Sha512.html]> FOR HASH
[struct.Sha512.html]

§

FN PARTIAL_CMP [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp](&SELF, OTHER: &HASH
[struct.Sha512.html]) -> OPTION [https://doc.rust-lang.org/1.67.0/core/option/enum.Option.html]<ORDERING
[https://doc.rust-lang.org/1.67.0/core/cmp/enum.Ordering.html]>

This method returns an ordering between self and other values if one exists. Read more
[https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp]
1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/cmp.rs.html#1126]§

FN LT [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialOrd.html#method.lt](&SELF, OTHER: &
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]RHS) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]

This method tests less than (for self and other) and is used by the < operator. Read more
[https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialOrd.html#method.lt]
1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/cmp.rs.html#1145]§

FN LE [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialOrd.html#method.le](&SELF, OTHER: &
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]RHS) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]

This method tests less than or equal to (for self and other) and is used by the <= operator. Read more
[https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialOrd.html#method.le]
1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/cmp.rs.html#1163]§

FN GT [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialOrd.html#method.gt](&SELF, OTHER: &
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]RHS) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]

This method tests greater than (for self and other) and is used by the > operator. Read more
[https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialOrd.html#method.gt]
1.0.0 · source [https://doc.rust-lang.org/1.67.0/src/core/cmp.rs.html#1182]§

FN GE [https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialOrd.html#method.ge](&SELF, OTHER: &
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]RHS) -> BOOL
[https://doc.rust-lang.org/1.67.0/std/primitive.bool.html]

This method tests greater than or equal to (for self and other) and is used by the >= operator. Read more
[https://doc.rust-lang.org/1.67.0/core/cmp/trait.PartialOrd.html#method.ge]
§


IMPL SERDEHASH FOR HASH [struct.Sha512.html]

§

CONST N: USIZE [https://doc.rust-lang.org/1.67.0/std/primitive.usize.html] = 64USIZE

Size, in bits, of the hash.
§

FN FROM_SLICE_DELEGATED(SL: &[U8 [https://doc.rust-lang.org/1.67.0/std/primitive.u8.html]]) -> RESULT
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<HASH [struct.Sha512.html], ERROR>

Helper function to turn a deserialized slice into the correct hash type.
§

FN SERIALIZE<S>(
    &SELF,
    S: S
) -> RESULT [https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<<S AS SERIALIZER
[https://docs.rs/serde/1.0.163/serde/ser/trait.Serializer.html]>::OK
[https://docs.rs/serde/1.0.163/serde/ser/trait.Serializer.html#associatedtype.Ok], <S AS SERIALIZER
[https://docs.rs/serde/1.0.163/serde/ser/trait.Serializer.html]>::ERROR
[https://docs.rs/serde/1.0.163/serde/ser/trait.Serializer.html#associatedtype.Error]>WHERE
    S: SERIALIZER [https://docs.rs/serde/1.0.163/serde/ser/trait.Serializer.html],

Do serde serialization.
§

FN DESERIALIZE<'DE, D>(D: D) -> RESULT [https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<SELF, <D AS DESERIALIZER
[https://docs.rs/serde/1.0.163/serde/de/trait.Deserializer.html]<'DE>>::ERROR
[https://docs.rs/serde/1.0.163/serde/de/trait.Deserializer.html#associatedtype.Error]>WHERE
    D: DESERIALIZER [https://docs.rs/serde/1.0.163/serde/de/trait.Deserializer.html]<'DE>,

Do serde deserialization.
§


IMPL SERIALIZE [https://docs.rs/serde/1.0.163/serde/ser/trait.Serialize.html] FOR HASH [struct.Sha512.html]

§

FN SERIALIZE [https://docs.rs/serde/1.0.163/serde/ser/trait.Serialize.html#tymethod.serialize]<S>(
    &SELF,
    S: S
) -> RESULT [https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<<S AS SERIALIZER
[https://docs.rs/serde/1.0.163/serde/ser/trait.Serializer.html]>::OK
[https://docs.rs/serde/1.0.163/serde/ser/trait.Serializer.html#associatedtype.Ok], <S AS SERIALIZER
[https://docs.rs/serde/1.0.163/serde/ser/trait.Serializer.html]>::ERROR
[https://docs.rs/serde/1.0.163/serde/ser/trait.Serializer.html#associatedtype.Error]>WHERE
    S: SERIALIZER [https://docs.rs/serde/1.0.163/serde/ser/trait.Serializer.html],

Serialize this value into the given Serde serializer. Read more
[https://docs.rs/serde/1.0.163/serde/ser/trait.Serialize.html#tymethod.serialize]
§


IMPL COPY [https://doc.rust-lang.org/1.67.0/core/marker/trait.Copy.html] FOR HASH [struct.Sha512.html]

§


IMPL EQ [https://doc.rust-lang.org/1.67.0/core/cmp/trait.Eq.html] FOR HASH [struct.Sha512.html]


AUTO TRAIT IMPLEMENTATIONS§

§


IMPL REFUNWINDSAFE [https://doc.rust-lang.org/1.67.0/core/panic/unwind_safe/trait.RefUnwindSafe.html] FOR HASH
[struct.Sha512.html]

§


IMPL SEND [https://doc.rust-lang.org/1.67.0/core/marker/trait.Send.html] FOR HASH [struct.Sha512.html]

§


IMPL SYNC [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sync.html] FOR HASH [struct.Sha512.html]

§


IMPL UNPIN [https://doc.rust-lang.org/1.67.0/core/marker/trait.Unpin.html] FOR HASH [struct.Sha512.html]

§


IMPL UNWINDSAFE [https://doc.rust-lang.org/1.67.0/core/panic/unwind_safe/trait.UnwindSafe.html] FOR HASH [struct.Sha512.html]


BLANKET IMPLEMENTATIONS§

source [https://doc.rust-lang.org/1.67.0/src/core/any.rs.html#200]§


IMPL<T> ANY [https://doc.rust-lang.org/1.67.0/core/any/trait.Any.html] FOR TWHERE
    T: 'STATIC + ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

source [https://doc.rust-lang.org/1.67.0/src/core/any.rs.html#201]§

FN TYPE_ID [https://doc.rust-lang.org/1.67.0/core/any/trait.Any.html#tymethod.type_id](&SELF) -> TYPEID
[https://doc.rust-lang.org/1.67.0/core/any/struct.TypeId.html]

Gets the TypeId of self. Read more [https://doc.rust-lang.org/1.67.0/core/any/trait.Any.html#tymethod.type_id]
source [https://doc.rust-lang.org/1.67.0/src/core/borrow.rs.html#211]§


IMPL<T> BORROW [https://doc.rust-lang.org/1.67.0/core/borrow/trait.Borrow.html]<T> FOR TWHERE
    T: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

const: unstable [https://github.com/rust-lang/rust/issues/91522] · source
[https://doc.rust-lang.org/1.67.0/src/core/borrow.rs.html#213]§

FN BORROW [https://doc.rust-lang.org/1.67.0/core/borrow/trait.Borrow.html#tymethod.borrow](&SELF) -> &
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T

Immutably borrows from an owned value. Read more [https://doc.rust-lang.org/1.67.0/core/borrow/trait.Borrow.html#tymethod.borrow]
source [https://doc.rust-lang.org/1.67.0/src/core/borrow.rs.html#220]§


IMPL<T> BORROWMUT [https://doc.rust-lang.org/1.67.0/core/borrow/trait.BorrowMut.html]<T> FOR TWHERE
    T: ?SIZED [https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

const: unstable [https://github.com/rust-lang/rust/issues/91522] · source
[https://doc.rust-lang.org/1.67.0/src/core/borrow.rs.html#221]§

FN BORROW_MUT [https://doc.rust-lang.org/1.67.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut](&MUT SELF) -> &MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T

Mutably borrows from an owned value. Read more
[https://doc.rust-lang.org/1.67.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut]
source [https://doc.rust-lang.org/1.67.0/src/core/convert/mod.rs.html#733]§


IMPL<T> FROM [https://doc.rust-lang.org/1.67.0/core/convert/trait.From.html]<T> FOR T

const: unstable [https://github.com/rust-lang/rust/issues/88674] · source
[https://doc.rust-lang.org/1.67.0/src/core/convert/mod.rs.html#736]§

FN FROM [https://doc.rust-lang.org/1.67.0/core/convert/trait.From.html#tymethod.from](T: T) -> T

Returns the argument unchanged.

§


IMPL<T> FROMHEX FOR TWHERE
    T: HASH [../trait.BitcoinHash.html],

§

FN FROM_BYTE_ITER<I>(ITER: I) -> RESULT [https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<T, ERROR>WHERE
    I: ITERATOR [https://doc.rust-lang.org/1.67.0/core/iter/traits/iterator/trait.Iterator.html]<ITEM = RESULT
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<U8 [https://doc.rust-lang.org/1.67.0/std/primitive.u8.html],
ERROR>> + EXACTSIZEITERATOR [https://doc.rust-lang.org/1.67.0/core/iter/traits/exact_size/trait.ExactSizeIterator.html] +
DOUBLEENDEDITERATOR [https://doc.rust-lang.org/1.67.0/core/iter/traits/double_ended/trait.DoubleEndedIterator.html],

Produces an object from a byte iterator.
§

FN FROM_HEX(S: &STR [https://doc.rust-lang.org/1.67.0/std/primitive.str.html]) -> RESULT
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<SELF, ERROR>

Produces an object from a hex string.
source [https://doc.rust-lang.org/1.67.0/src/core/convert/mod.rs.html#717]§


IMPL<T, U> INTO [https://doc.rust-lang.org/1.67.0/core/convert/trait.Into.html]<U> FOR TWHERE
    U: FROM [https://doc.rust-lang.org/1.67.0/core/convert/trait.From.html]<T>,

const: unstable [https://github.com/rust-lang/rust/issues/88674] · source
[https://doc.rust-lang.org/1.67.0/src/core/convert/mod.rs.html#725]§

FN INTO [https://doc.rust-lang.org/1.67.0/core/convert/trait.Into.html#tymethod.into](SELF) -> U

Calls U::from(self).

That is, this conversion is whatever the implementation of From [https://doc.rust-lang.org/1.67.0/core/convert/trait.From.html]<T>
for U chooses to do.

§


IMPL<T> TOHEX FOR TWHERE
    T: LOWERHEX [https://doc.rust-lang.org/1.67.0/core/fmt/trait.LowerHex.html],

§

FN TO_HEX(&SELF) -> STRING [https://doc.rust-lang.org/1.67.0/alloc/string/struct.String.html]

Outputs the hash in hexadecimal form.

source [https://doc.rust-lang.org/1.67.0/src/alloc/borrow.rs.html#82]§


IMPL<T> TOOWNED [https://doc.rust-lang.org/1.67.0/alloc/borrow/trait.ToOwned.html] FOR TWHERE
    T: CLONE [https://doc.rust-lang.org/1.67.0/core/clone/trait.Clone.html],

§

TYPE OWNED [https://doc.rust-lang.org/1.67.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned] = T

The resulting type after obtaining ownership.
source [https://doc.rust-lang.org/1.67.0/src/alloc/borrow.rs.html#87]§

FN TO_OWNED [https://doc.rust-lang.org/1.67.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned](&SELF) -> T

Creates owned data from borrowed data, usually by cloning. Read more
[https://doc.rust-lang.org/1.67.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned]
source [https://doc.rust-lang.org/1.67.0/src/alloc/borrow.rs.html#91]§

FN CLONE_INTO [https://doc.rust-lang.org/1.67.0/alloc/borrow/trait.ToOwned.html#method.clone_into](&SELF, TARGET: &MUT
[https://doc.rust-lang.org/1.67.0/std/primitive.reference.html]T)

Uses borrowed data to replace owned data, usually by cloning. Read more
[https://doc.rust-lang.org/1.67.0/alloc/borrow/trait.ToOwned.html#method.clone_into]
source [https://doc.rust-lang.org/1.67.0/src/alloc/string.rs.html#2526]§


IMPL<T> TOSTRING [https://doc.rust-lang.org/1.67.0/alloc/string/trait.ToString.html] FOR TWHERE
    T: DISPLAY [https://doc.rust-lang.org/1.67.0/core/fmt/trait.Display.html] + ?SIZED
[https://doc.rust-lang.org/1.67.0/core/marker/trait.Sized.html],

source [https://doc.rust-lang.org/1.67.0/src/alloc/string.rs.html#2532]§

DEFAULT FN TO_STRING [https://doc.rust-lang.org/1.67.0/alloc/string/trait.ToString.html#tymethod.to_string](&SELF) -> STRING
[https://doc.rust-lang.org/1.67.0/alloc/string/struct.String.html]

Converts the given value to a String. Read more
[https://doc.rust-lang.org/1.67.0/alloc/string/trait.ToString.html#tymethod.to_string]
source [https://doc.rust-lang.org/1.67.0/src/core/convert/mod.rs.html#775]§


IMPL<T, U> TRYFROM [https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html]<U> FOR TWHERE
    U: INTO [https://doc.rust-lang.org/1.67.0/core/convert/trait.Into.html]<T>,

§

TYPE ERROR [https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html#associatedtype.Error] = INFALLIBLE
[https://doc.rust-lang.org/1.67.0/core/convert/enum.Infallible.html]

The type returned in the event of a conversion error.
const: unstable [https://github.com/rust-lang/rust/issues/88674] · source
[https://doc.rust-lang.org/1.67.0/src/core/convert/mod.rs.html#781]§

FN TRY_FROM [https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html#tymethod.try_from](VALUE: U) -> RESULT
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<T, <T AS TRYFROM
[https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html]<U>>::ERROR
[https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html#associatedtype.Error]>

Performs the conversion.
source [https://doc.rust-lang.org/1.67.0/src/core/convert/mod.rs.html#760]§


IMPL<T, U> TRYINTO [https://doc.rust-lang.org/1.67.0/core/convert/trait.TryInto.html]<U> FOR TWHERE
    U: TRYFROM [https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html]<T>,

§

TYPE ERROR [https://doc.rust-lang.org/1.67.0/core/convert/trait.TryInto.html#associatedtype.Error] = <U AS TRYFROM
[https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html]<T>>::ERROR
[https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html#associatedtype.Error]

The type returned in the event of a conversion error.
const: unstable [https://github.com/rust-lang/rust/issues/88674] · source
[https://doc.rust-lang.org/1.67.0/src/core/convert/mod.rs.html#766]§

FN TRY_INTO [https://doc.rust-lang.org/1.67.0/core/convert/trait.TryInto.html#tymethod.try_into](SELF) -> RESULT
[https://doc.rust-lang.org/1.67.0/core/result/enum.Result.html]<U, <U AS TRYFROM
[https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html]<T>>::ERROR
[https://doc.rust-lang.org/1.67.0/core/convert/trait.TryFrom.html#associatedtype.Error]>

Performs the conversion.
source [https://docs.rs/serde/1.0.163/src/serde/de/mod.rs.html#604]§


IMPL<T> DESERIALIZEOWNED [https://docs.rs/serde/1.0.163/serde/de/trait.DeserializeOwned.html] FOR TWHERE
    T: FOR<'DE> DESERIALIZE [https://docs.rs/serde/1.0.163/serde/de/trait.Deserialize.html]<'DE>,

